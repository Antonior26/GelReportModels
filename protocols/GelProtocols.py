"""
DO NOT EDIT THIS FILE!!
This file is automatically generated by the process_schemas.py program
in the scripts directory. It is not intended to be edited directly. If
you need to update the GEL protocol classes, please run the script
on the appropriate schema version.
"""
from protocols.protocol import ProtocolElement
from protocols.protocol import SearchRequest
from protocols.protocol import SearchResponse

import avro.schema

version = '0.2.0'


class ActionableInformation(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"ActionableInformation", "fields": [{"doc": "", "type": ["null",
"string"], "name": "interventionCategory"}, {"doc": "", "type":
["null", "string"], "name": "clinicalTrials"}, {"doc": "", "type":
["null", "string"], "name": "pharmacogenetic"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "clinicalTrials",
        "interventionCategory",
        "pharmacogenetic",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'clinicalTrials', 'interventionCategory', 'pharmacogenetic'
    ]

    def __init__(self, **kwargs):
        self.clinicalTrials = kwargs.get(
            'clinicalTrials', None)
        self.interventionCategory = kwargs.get(
            'interventionCategory', None)
        self.pharmacogenetic = kwargs.get(
            'pharmacogenetic', None)


class AdditionalInformation(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"AdditionalInformation", "fields": [{"doc": "", "type": ["null",
"string"], "name": "consanguinity"}, {"doc": "", "type": ["null",
{"values": {"symbols": ["A", "B", "C", "D", "E", "F", "G", "H", "J",
"K", "L", "M", "N", "P", "S", "R", "Z"], "type": "enum", "name":
"EthnicOrigin"}, "type": "map"}], "name": "mothersEthnicOrigin"},
{"doc": "", "type": ["null", {"values": "EthnicOrigin", "type":
"map"}], "name": "fathersEthnicOrigin"}, {"doc": "", "type": ["null",
"string"], "name": "mothersOtherRelevantAncestry"}, {"doc": "",
"type": ["null", "string"], "name": "fathersOtherRelevantAncestry"},
{"doc": "", "type": ["null", "string", {"values": {"symbols":
["Colorectal_Cancer", "Breast_and_or_Ovarian_Cancer",
"Ischaemic_Heart_Disease_or_Stroke", "Endocrine_Tumours"], "type":
"enum", "name": "FamilyHistory"}, "type": "map"}], "name":
"maternalFamilyHistory"}, {"doc": "", "type": ["null", "string",
{"values": "FamilyHistory", "type": "map"}], "name":
"paternalFamilyHistory"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "consanguinity",
        "fathersEthnicOrigin",
        "fathersOtherRelevantAncestry",
        "maternalFamilyHistory",
        "mothersEthnicOrigin",
        "mothersOtherRelevantAncestry",
        "paternalFamilyHistory",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'consanguinity', 'fathersEthnicOrigin',
        'fathersOtherRelevantAncestry', 'maternalFamilyHistory',
        'mothersEthnicOrigin', 'mothersOtherRelevantAncestry',
        'paternalFamilyHistory'
    ]

    def __init__(self, **kwargs):
        self.consanguinity = kwargs.get(
            'consanguinity', None)
        self.fathersEthnicOrigin = kwargs.get(
            'fathersEthnicOrigin', None)
        self.fathersOtherRelevantAncestry = kwargs.get(
            'fathersOtherRelevantAncestry', None)
        self.maternalFamilyHistory = kwargs.get(
            'maternalFamilyHistory', None)
        self.mothersEthnicOrigin = kwargs.get(
            'mothersEthnicOrigin', None)
        self.mothersOtherRelevantAncestry = kwargs.get(
            'mothersOtherRelevantAncestry', None)
        self.paternalFamilyHistory = kwargs.get(
            'paternalFamilyHistory', None)


class AdoptedStatus(object):
    """
    adoptedin means adopted into the family adoptedout means child
    belonged to the family and was adopted out
    """
    not_adopted = "not_adopted"
    adoptedin = "adoptedin"
    adoptedout = "adoptedout"


class AffectionStatus(object):
    """
    Affection Status
    """
    unaffected = "unaffected"
    affected = "affected"
    unknown = "unknown"


class Ancestries(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"Ancestries", "fields": [{"doc": "", "type": ["null", {"symbols":
["D", "E", "F", "G", "A", "B", "C", "L", "M", "N", "H", "J", "K", "P",
"S", "R", "Z"], "doc": "", "type": "enum", "name": "EthnicCategory"}],
"name": "mothersEthnicOrigin"}, {"doc": "", "type": ["null",
"string"], "name": "mothersOtherRelevantAncestry"}, {"doc": "",
"type": ["null", "EthnicCategory"], "name": "fathersEthnicOrigin"},
{"doc": "", "type": ["null", "string"], "name":
"fathersOtherRelevantAncestry"}, {"doc": "", "type": ["null",
{"items": {"doc": "", "type": "record", "name":
"ChiSquare1KGenomesPhase3Pop", "fields": [{"doc": "", "type":
{"symbols": ["AFR", "AMR", "EAS", "EUR", "SAS"], "doc": "", "type":
"enum", "name": "KGSuperPopCategory"}, "name": "kGSuperPopCategory"},
{"doc": "", "type": ["null", {"symbols": ["ACB", "ASW", "BEB", "CDX",
"CEU", "CHB", "CHS", "CLM", "ESN", "FIN", "GBR", "GIH", "GWD", "IBS",
"ITU", "JPT", "KHV", "LWK", "MSL", "MXL", "PEL", "PJL", "PUR", "STU",
"TSI", "YRI"], "doc": "", "type": "enum", "name": "KGPopCategory"}],
"name": "kGPopCategory"}, {"doc": "", "type": "float", "name":
"chiSquare"}]}, "type": "array"}], "name":
"chiSquare1KGenomesPhase3Pop"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "chiSquare1KGenomesPhase3Pop",
        "fathersEthnicOrigin",
        "fathersOtherRelevantAncestry",
        "mothersEthnicOrigin",
        "mothersOtherRelevantAncestry",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'chiSquare1KGenomesPhase3Pop', 'fathersEthnicOrigin',
        'fathersOtherRelevantAncestry', 'mothersEthnicOrigin',
        'mothersOtherRelevantAncestry'
    ]

    def __init__(self, **kwargs):
        self.chiSquare1KGenomesPhase3Pop = kwargs.get(
            'chiSquare1KGenomesPhase3Pop', None)
        self.fathersEthnicOrigin = kwargs.get(
            'fathersEthnicOrigin', None)
        self.fathersOtherRelevantAncestry = kwargs.get(
            'fathersOtherRelevantAncestry', None)
        self.mothersEthnicOrigin = kwargs.get(
            'mothersEthnicOrigin', None)
        self.mothersOtherRelevantAncestry = kwargs.get(
            'mothersOtherRelevantAncestry', None)


class CalledGenotype(ProtocolElement):
    """
    This is intended to hold the genotypes for the family members In
    principle it is a phased zygosity as in VCF spec and called by the
    analysis provider if further phasing is conducted
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CalledGenotype", "fields": [{"doc": "", "type": "string", "name":
"gelId"}, {"doc": "", "type": "string", "name": "genotype"}, {"doc":
"", "type": ["null", "int"], "name": "depthReference"}, {"doc": "",
"type": ["null", "int"], "name": "depthAlternate"}, {"doc": "",
"type": ["null", "int"], "name": "copyNumber"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "copyNumber",
        "depthAlternate",
        "depthReference",
        "gelId",
        "genotype",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'copyNumber', 'depthAlternate', 'depthReference', 'gelId',
        'genotype'
    ]

    def __init__(self, **kwargs):
        self.copyNumber = kwargs.get(
            'copyNumber', None)
        self.depthAlternate = kwargs.get(
            'depthAlternate', None)
        self.depthReference = kwargs.get(
            'depthReference', None)
        self.gelId = kwargs.get(
            'gelId', 'None')
        self.genotype = kwargs.get(
            'genotype', 'None')


class CancerCaseLog(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CancerCaseLog", "fields": [{"doc": "", "type": ["null", {"doc": "",
"type": "record", "name": "CommonQualityControl", "fields": [{"doc":
"", "type": ["null", {"items": {"doc": "", "type": "record", "name":
"File", "fields": [{"doc": "", "type": ["null", "string", {"items":
"string", "type": "array"}], "name": "SampleId"}, {"doc": "", "type":
"string", "name": "URIFile"}]}, "type": "array"}], "name":
"mendelErrors"}, {"doc": "", "type": ["null", {"items": "File",
"type": "array"}], "name": "sexPrediction"}, {"doc": "", "type":
["null", {"items": "File", "type": "array"}], "name":
"relatednessCheck"}, {"doc": "", "type": ["null", {"items": "File",
"type": "array"}], "name": "humanContminationFraction"}]}], "name":
"commonQualityControl"}, {"doc": "", "type": ["null", {"fields":
[{"doc": "", "type": {"items": "File", "type": "array"}, "name":
"tumourPurity"}, {"doc": "", "type": {"items": "File", "type":
"array"}, "name": "tumourPloidy"}], "type": "record", "name":
"Tumour"}], "name": "tumour"}, {"doc": "", "type": ["null", {"fields":
[{"doc": "", "type": {"items": "File", "type": "array"}, "name":
"sampleProvenance"}, {"doc": "", "type": {"items": "File", "type":
"array"}, "name": "concordanceChecks"}, {"doc": "", "type": ["null",
{"items": "File", "type": "array"}], "name": "pathogenDetection"},
{"doc": "", "type": ["null", {"items": "File", "type": "array"}],
"name": "crossSpeciesContamination"}], "type": "record", "name":
"Provenance"}], "name": "Provenance"}, {"doc": "", "type": ["null",
{"fields": [{"doc": "", "type": {"items": "File", "type": "array"},
"name": "circusPlot"}, {"doc": "", "type": {"items": "File", "type":
"array"}, "name": "copyNumberPlot"}, {"doc": "", "type": {"items":
"File", "type": "array"}, "name": "FusionGenes"}], "type": "record",
"name": "CancerMetrics"}], "name": "cancerMetrics"}, {"doc": "",
"type": ["null", {"doc": "", "type": "record", "name":
"TieredVariants", "fields": [{"doc": "", "type": ["null", "double"],
"name": "totalNoTier1"}, {"doc": "", "type": ["null", "double"],
"name": "totalNoTier2"}, {"doc": "", "type": ["null", "double"],
"name": "totalNoTier3"}]}], "name": "tieredVariants"}, {"doc": "",
"type": ["null", {"doc": "", "type": "record", "name":
"InterpretationAuthorisation", "fields": [{"doc": "", "type": ["null",
"string"], "name": "interpretationAuthorisationDate"}, {"doc": "",
"type": ["null", "string"], "name": "nameOfAuthoriser"}, {"doc": "",
"type": ["null", {"items": {"doc": "", "type": "record", "name":
"ReportEvents", "fields": [{"doc": "", "type": ["null", "string"],
"name": "reportEventId"}, {"doc": "", "type": ["null", {"symbols":
["approved", "rejected"], "type": "enum", "name":
"ReportEventStatus"}], "name": "reportEventStatus"}, {"doc": "",
"type": ["null", "string"], "name": "authorisationJustification"}]},
"type": "array"}], "name": "reportEvents"}]}], "name":
"interpretationAuthorisation"}, {"doc": "", "type": "string", "name":
"gelInterimID"}, {"doc": "", "type": {"fields": [{"doc": "", "type":
"string", "name": "reportID"}, {"doc": "", "type": "float", "name":
"reportDate"}], "type": "record", "name": "Tracking"}, "name":
"tracking"}, {"doc": "", "type": {"doc": "", "type": "record", "name":
"ConsentStatus", "fields": [{"default": false, "doc": "", "type":
"boolean", "name": "programmeConsent"}, {"default": false, "doc": "",
"type": "boolean", "name": "primaryFindingConsent"}, {"default":
false, "doc": "", "type": "boolean", "name":
"secondaryFindingConsent"}, {"default": false, "doc": "", "type":
"boolean", "name": "carrierStatusConsent"}]}, "name":
"consentStatus"}, {"doc": "", "type": ["null", {"fields": [{"doc": "",
"type": "string", "name": "genePanelName"}, {"doc": "", "type":
"string", "name": "genePanelVersion"}], "type": "record", "name":
"GenePanels"}], "name": "genePanels"}, {"doc": "", "type": ["null",
{"fields": [{"doc": "", "type": {"items": "File", "type": "array"},
"name": "genomeWideCoverage15x"}, {"doc": "", "type": {"items":
"File", "type": "array"}, "name": "genomeWideCoverage30"}, {"doc": "",
"type": ["null", {"items": "File", "type": "array"}], "name":
"genePanelCoveragePanel"}, {"doc": "", "type": ["null", {"items":
"File", "type": "array"}], "name": "genePanelCoverageGenes"}], "type":
"record", "name": "CoverageMetrics"}], "name": "coverageMetrics"},
{"doc": "", "type": ["null", "Provenance"], "name": "provenance"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "Provenance",
        "cancerMetrics",
        "commonQualityControl",
        "consentStatus",
        "coverageMetrics",
        "gelInterimID",
        "genePanels",
        "interpretationAuthorisation",
        "provenance",
        "tieredVariants",
        "tracking",
        "tumour",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'Provenance': Provenance,
            'cancerMetrics': CancerMetrics,
            'commonQualityControl': CommonQualityControl,
            'consentStatus': ConsentStatus,
            'coverageMetrics': CoverageMetrics,
            'genePanels': GenePanels,
            'interpretationAuthorisation': InterpretationAuthorisation,
            'provenance': Provenance,
            'tieredVariants': TieredVariants,
            'tracking': Tracking,
            'tumour': Tumour,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'Provenance': Provenance,
            'cancerMetrics': CancerMetrics,
            'commonQualityControl': CommonQualityControl,
            'consentStatus': ConsentStatus,
            'coverageMetrics': CoverageMetrics,
            'genePanels': GenePanels,
            'interpretationAuthorisation': InterpretationAuthorisation,
            'provenance': Provenance,
            'tieredVariants': TieredVariants,
            'tracking': Tracking,
            'tumour': Tumour,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'Provenance', 'cancerMetrics', 'commonQualityControl',
        'consentStatus', 'coverageMetrics', 'gelInterimID',
        'genePanels', 'interpretationAuthorisation', 'provenance',
        'tieredVariants', 'tracking', 'tumour'
    ]

    def __init__(self, **kwargs):
        self.Provenance = kwargs.get(
            'Provenance', None)
        self.cancerMetrics = kwargs.get(
            'cancerMetrics', None)
        self.commonQualityControl = kwargs.get(
            'commonQualityControl', None)
        self.consentStatus = kwargs.get(
            'consentStatus', None)
        self.coverageMetrics = kwargs.get(
            'coverageMetrics', None)
        self.gelInterimID = kwargs.get(
            'gelInterimID', 'None')
        self.genePanels = kwargs.get(
            'genePanels', None)
        self.interpretationAuthorisation = kwargs.get(
            'interpretationAuthorisation', None)
        self.provenance = kwargs.get(
            'provenance', None)
        self.tieredVariants = kwargs.get(
            'tieredVariants', None)
        self.tracking = kwargs.get(
            'tracking', None)
        self.tumour = kwargs.get(
            'tumour', None)


class CancerDemographics(ProtocolElement):
    """
    This defines a Cancer Demographics
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CancerDemographics", "fields": [{"doc": "", "type": "string", "name":
"gelId"}, {"doc": "", "type": "string", "name": "primaryDiagnosis"},
{"default": "v2.4", "doc": "", "type": "string", "name":
"dataModelVersion"}, {"doc": "", "type": {"symbols": ["male",
"female", "undetermined"], "doc": "", "type": "enum", "name": "Sex"},
"name": "sex"}, {"doc": "", "type": {"doc": "", "type": "record",
"name": "ConsentStatus", "fields": [{"default": false, "doc": "",
"type": "boolean", "name": "programmeConsent"}, {"default": false,
"doc": "", "type": "boolean", "name": "primaryFindingConsent"},
{"default": false, "doc": "", "type": "boolean", "name":
"secondaryFindingConsent"}, {"default": false, "doc": "", "type":
"boolean", "name": "carrierStatusConsent"}]}, "name":
"consentStatus"}, {"doc": "", "type": ["null", {"values": "string",
"type": "map"}], "name": "additionalInformation"}, {"doc": "", "type":
{"items": "string", "type": "array"}, "name": "sampleId"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "additionalInformation",
        "consentStatus",
        "gelId",
        "primaryDiagnosis",
        "sampleId",
        "sex",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'consentStatus': ConsentStatus,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'consentStatus': ConsentStatus,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'additionalInformation', 'consentStatus', 'dataModelVersion',
        'gelId', 'primaryDiagnosis', 'sampleId', 'sex'
    ]

    def __init__(self, **kwargs):
        self.additionalInformation = kwargs.get(
            'additionalInformation', None)
        self.consentStatus = kwargs.get(
            'consentStatus', None)
        self.dataModelVersion = kwargs.get(
            'dataModelVersion', 'v2.4')
        self.gelId = kwargs.get(
            'gelId', 'None')
        self.primaryDiagnosis = kwargs.get(
            'primaryDiagnosis', 'None')
        self.sampleId = kwargs.get(
            'sampleId', None)
        self.sex = kwargs.get(
            'sex', None)


class CancerDisclaimers(ProtocolElement):
    """
    includes MatchedSamples
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CancerDisclaimers", "fields": [{"doc": "", "type": "string", "name":
"CancerResearchDisclaimer"}, {"doc": "", "type": "string", "name":
"reportContext"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "CancerResearchDisclaimer",
        "reportContext",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'CancerResearchDisclaimer', 'reportContext'
    ]

    def __init__(self, **kwargs):
        self.CancerResearchDisclaimer = kwargs.get(
            'CancerResearchDisclaimer', 'None')
        self.reportContext = kwargs.get(
            'reportContext', 'None')


class CancerInterpretationRequest(ProtocolElement):
    """
    This record represents basic information for this report  TODO:
    change/specialise InterpretationRequest >
    CancerInterpretationRequest currently does not load... python
    build.py
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CancerInterpretationRequest", "fields": [{"doc": "", "type":
"string", "name": "reportRequestId"}, {"doc": "", "type": "int",
"name": "reportVersion"}, {"default": false, "doc": "", "type":
"boolean", "name": "interpretGenome"}, {"doc": "", "type": {"items":
{"doc": "", "type": "record", "name": "File", "fields": [{"doc": "",
"type": ["null", "string", {"items": "string", "type": "array"}],
"name": "SampleId"}, {"doc": "", "type": "string", "name":
"URIFile"}]}, "type": "array"}, "name": "BAMs"}, {"doc": "", "type":
{"items": "File", "type": "array"}, "name": "gVCFs"}, {"doc": "",
"type": {"items": "File", "type": "array"}, "name": "VCFs"}, {"doc":
"", "type": {"items": "File", "type": "array"}, "name": "BigWigs"},
{"doc": "", "type": "File", "name": "annotationFile"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "VirtualPanel",
"fields": [{"doc": "", "type": "string", "name":
"specificDiseaseTitle"}, {"doc": "", "type": "string", "name":
"panelVersion"}, {"doc": "", "type": "string", "name":
"ensemblVersion"}, {"doc": "", "type": "string", "name":
"dataModelCatalogueVersion"}, {"doc": "", "type": {"items": "string",
"type": "array"}, "name": "geneIds"}, {"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "Transcripts"}, {"doc":
"", "type": ["null", "File"], "name": "relevantRegions"}, {"doc": "",
"type": ["null", "File"], "name": "clinicalRelevantVariants"}]},
"name": "virtualPanels"}, {"type": "string", "name": "analysisURI"},
{"type": "string", "name": "analysisVersion"}, {"doc": "", "type":
["null", {"values": "string", "type": "map"}], "name":
"additionalInfo"}, {"doc": "", "type": {"doc": "", "type": "record",
"name": "OtherFamilyHistory", "fields": [{"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name":
"maternalFamilyHistory"}, {"doc": "", "type": ["null", {"items":
"string", "type": "array"}], "name": "paternalFamilyHistory"}]},
"name": "otherFamilyHistory"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "BAMs",
        "BigWigs",
        "VCFs",
        "additionalInfo",
        "analysisURI",
        "analysisVersion",
        "annotationFile",
        "gVCFs",
        "otherFamilyHistory",
        "reportRequestId",
        "reportVersion",
        "virtualPanels",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'BAMs': File,
            'BigWigs': File,
            'VCFs': File,
            'annotationFile': File,
            'gVCFs': File,
            'otherFamilyHistory': OtherFamilyHistory,
            'virtualPanels': VirtualPanel,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'BAMs': File,
            'BigWigs': File,
            'VCFs': File,
            'annotationFile': File,
            'gVCFs': File,
            'otherFamilyHistory': OtherFamilyHistory,
            'virtualPanels': VirtualPanel,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'BAMs', 'BigWigs', 'VCFs', 'additionalInfo', 'analysisURI',
        'analysisVersion', 'annotationFile', 'gVCFs',
        'interpretGenome', 'otherFamilyHistory', 'reportRequestId',
        'reportVersion', 'virtualPanels'
    ]

    def __init__(self, **kwargs):
        self.BAMs = kwargs.get(
            'BAMs', None)
        self.BigWigs = kwargs.get(
            'BigWigs', None)
        self.VCFs = kwargs.get(
            'VCFs', None)
        self.additionalInfo = kwargs.get(
            'additionalInfo', None)
        self.analysisURI = kwargs.get(
            'analysisURI', 'None')
        self.analysisVersion = kwargs.get(
            'analysisVersion', 'None')
        self.annotationFile = kwargs.get(
            'annotationFile', None)
        self.gVCFs = kwargs.get(
            'gVCFs', None)
        self.interpretGenome = kwargs.get(
            'interpretGenome', False)
        self.otherFamilyHistory = kwargs.get(
            'otherFamilyHistory', None)
        self.reportRequestId = kwargs.get(
            'reportRequestId', 'None')
        self.reportVersion = kwargs.get(
            'reportVersion', None)
        self.virtualPanels = kwargs.get(
            'virtualPanels', None)


class CancerInterpretedGenome(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CancerInterpretedGenome", "fields": [{"doc": "", "type": "string",
"name": "reportRequestId"}, {"doc": "", "type": "string", "name":
"analysisId"}, {"doc": "", "type": "string", "name": "companyName"},
{"doc": "", "type": "string", "name": "reportURI"}, {"type": {"items":
{"fields": [{"doc": "", "type": {"fields": [{"doc": "", "type":
"string", "name": "chromosome"}, {"doc": "", "type": ["null",
"string"], "name": "dbSNPid"}, {"doc": "", "type": "int", "name":
"position"}, {"doc": "", "type": "string", "name": "reference"},
{"doc": "", "type": "string", "name": "alternate"}, {"doc": "",
"type": {"items": {"doc": "", "type": "record", "name":
"CalledGenotype", "fields": [{"doc": "", "type": "string", "name":
"gelId"}, {"doc": "", "type": "string", "name": "genotype"}, {"doc":
"", "type": ["null", "int"], "name": "depthReference"}, {"doc": "",
"type": ["null", "int"], "name": "depthAlternate"}, {"doc": "",
"type": ["null", "int"], "name": "copyNumber"}]}, "type": "array"},
"name": "calledGenotypes"}, {"doc": "", "type": {"items": {"fields":
[{"doc": "", "type": "string", "name": "reportEventId"}, {"doc": "",
"type": "string", "name": "modeOfInheritance"}, {"doc": "", "type":
{"fields": [{"doc": "", "type": "string", "name": "geneSymbol"},
{"doc": "", "type": "string", "name": "transcriptId"}, {"doc": "",
"type": {"values": "string", "type": "map"}, "name": "ids"}, {"doc":
"", "type": ["null", "double"], "name": "geneCoverage"}], "type":
"record", "name": "Transcript"}, "name": "transcript"}, {"doc": "",
"type": {"symbols": ["complete", "incomplete"], "doc": "", "type":
"enum", "name": "Penetrance"}, "name": "penetrance"}, {"doc": "",
"type": "float", "name": "score"}, {"doc": "", "type": ["null",
{"values": "float", "type": "map"}], "name": "vendorSpecificScores"},
{"doc": "", "type": ["null", {"symbols": ["BENIGN", "LIKELY_BENIGN",
"VUS", "LIKELY_PATHOGENIC", "PATHOGENIC"], "doc": "", "type": "enum",
"name": "VariantClassification"}], "name": "variantClassification"},
{"doc": "", "type": ["null", "boolean"], "name":
"fullyExplainsPhenotype"}, {"doc": "", "type": ["null", "int"],
"name": "groupOfVariants"}, {"doc": "", "type": "string", "name":
"eventJustification"}, {"doc": "", "type": ["null", {"symbols":
["NONE", "TIER1", "TIER2", "TIER3"], "doc": "", "type": "enum",
"name": "Tier"}], "name": "tier"}], "type": "record", "name":
"ReportEvent"}, "type": "array"}, "name": "reportEvents"}, {"doc": "",
"type": ["null", {"values": "string", "type": "map"}], "name":
"additionalTextualVariantAnnotations"}, {"doc": "", "type": ["null",
{"values": "float", "type": "map"}], "name":
"additionalNumericVariantAnnotations"}, {"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "comments"}], "type":
"record", "name": "ReportedVariant"}, "name": "reportedVariant"},
{"doc": "", "type": {"symbols": ["unknown", "somatic", "germline"],
"doc": "", "type": "enum", "name": "SomaticOrGermline"}, "name":
"somaticOrGermline"}], "type": "record", "name":
"ReportedSomaticVariants"}, "type": "array"}, "name":
"reportedVariants"}, {"type": {"items": {"fields": [{"doc": "",
"type": {"fields": [{"doc": "", "type": "string", "name":
"chromosome"}, {"doc": "", "type": "int", "name": "start"}, {"doc":
"", "type": "int", "name": "end"}, {"doc": "", "type": "string",
"name": "type"}, {"doc": "", "type": "string", "name": "reference"},
{"doc": "", "type": "string", "name": "alternate"}, {"type": {"items":
"CalledGenotype", "type": "array"}, "name": "calledGenotypes"},
{"doc": "", "type": {"items": "ReportEvent", "type": "array"}, "name":
"reportEvents"}, {"doc": "", "type": ["null", {"values": "string",
"type": "map"}], "name": "additionalTextualVariantAnnotations"},
{"doc": "", "type": ["null", {"values": "float", "type": "map"}],
"name": "additionalNumericVariantAnnotations"}, {"doc": "", "type":
["null", {"items": "string", "type": "array"}], "name": "comments"}],
"type": "record", "name": "ReportedStructuralVariant"}, "name":
"reportedStructuralVariant"}, {"doc": "", "type": "SomaticOrGermline",
"name": "somaticOrGermline"}], "type": "record", "name":
"ReportedSomaticStructuralVariants"}, "type": "array"}, "name":
"reportedStructuralVariants"}, {"doc": "", "type": ["null", {"items":
"string", "type": "array"}], "name": "comments"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "analysisId",
        "comments",
        "companyName",
        "reportRequestId",
        "reportURI",
        "reportedStructuralVariants",
        "reportedVariants",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'reportedStructuralVariants': ReportedSomaticStructuralVariants,
            'reportedVariants': ReportedSomaticVariants,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'reportedStructuralVariants': ReportedSomaticStructuralVariants,
            'reportedVariants': ReportedSomaticVariants,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'analysisId', 'comments', 'companyName', 'reportRequestId',
        'reportURI', 'reportedStructuralVariants', 'reportedVariants'
    ]

    def __init__(self, **kwargs):
        self.analysisId = kwargs.get(
            'analysisId', 'None')
        self.comments = kwargs.get(
            'comments', None)
        self.companyName = kwargs.get(
            'companyName', 'None')
        self.reportRequestId = kwargs.get(
            'reportRequestId', 'None')
        self.reportURI = kwargs.get(
            'reportURI', 'None')
        self.reportedStructuralVariants = kwargs.get(
            'reportedStructuralVariants', None)
        self.reportedVariants = kwargs.get(
            'reportedVariants', None)


class CancerMetrics(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CancerMetrics", "fields": [{"doc": "", "type": {"items": {"doc": "",
"type": "record", "name": "File", "fields": [{"doc": "", "type":
["null", "string", {"items": "string", "type": "array"}], "name":
"SampleId"}, {"doc": "", "type": "string", "name": "URIFile"}]},
"type": "array"}, "name": "circusPlot"}, {"doc": "", "type": {"items":
"File", "type": "array"}, "name": "copyNumberPlot"}, {"doc": "",
"type": {"items": "File", "type": "array"}, "name": "FusionGenes"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "FusionGenes",
        "circusPlot",
        "copyNumberPlot",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'FusionGenes': File,
            'circusPlot': File,
            'copyNumberPlot': File,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'FusionGenes': File,
            'circusPlot': File,
            'copyNumberPlot': File,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'FusionGenes', 'circusPlot', 'copyNumberPlot'
    ]

    def __init__(self, **kwargs):
        self.FusionGenes = kwargs.get(
            'FusionGenes', None)
        self.circusPlot = kwargs.get(
            'circusPlot', None)
        self.copyNumberPlot = kwargs.get(
            'copyNumberPlot', None)


class CancerParticipant(ProtocolElement):
    """
    This defines a Cancer Participant (demographics and sample
    information)
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CancerParticipant", "fields": [{"doc": "", "type": {"doc": "",
"type": "record", "name": "CancerDemographics", "fields": [{"doc": "",
"type": "string", "name": "gelId"}, {"doc": "", "type": "string",
"name": "primaryDiagnosis"}, {"default": "v2.4", "doc": "", "type":
"string", "name": "dataModelVersion"}, {"doc": "", "type": {"symbols":
["male", "female", "undetermined"], "doc": "", "type": "enum", "name":
"Sex"}, "name": "sex"}, {"doc": "", "type": {"doc": "", "type":
"record", "name": "ConsentStatus", "fields": [{"default": false,
"doc": "", "type": "boolean", "name": "programmeConsent"}, {"default":
false, "doc": "", "type": "boolean", "name": "primaryFindingConsent"},
{"default": false, "doc": "", "type": "boolean", "name":
"secondaryFindingConsent"}, {"default": false, "doc": "", "type":
"boolean", "name": "carrierStatusConsent"}]}, "name":
"consentStatus"}, {"doc": "", "type": ["null", {"values": "string",
"type": "map"}], "name": "additionalInformation"}, {"doc": "", "type":
{"items": "string", "type": "array"}, "name": "sampleId"}]}, "name":
"cancerDemographics"}, {"doc": "", "type": {"items": {"fields":
[{"doc": "", "type": "string", "name": "sampleId"}, {"doc": "",
"type": {"symbols": ["germline", "tumor"], "type": "enum", "name":
"SampleType"}, "name": "sampleType"}, {"doc": "", "type": ["null",
"string"], "name": "source"}, {"doc": "", "type": ["null", {"symbols":
["FFPE", "FF", "Unknown", "LEUK", "GL"], "type": "enum", "name":
"PreservationMethod"}], "name": "preservationMethod"}, {"doc": "",
"type": ["null", {"symbols": ["primary", "metastasis"], "type":
"enum", "name": "Phase"}], "name": "phase"}, {"doc": "", "type":
["null", {"symbols": ["resection", "biopsy"], "type": "enum", "name":
"Method"}], "name": "method"}, {"doc": "", "type": ["null", "double"],
"name": "cellularity"}, {"doc": "", "type": ["null", "double"],
"name": "tumorContent"}], "type": "record", "name": "CancerSample"},
"type": "array"}, "name": "cancerSamples"}, {"doc": "", "type":
{"items": {"doc": "", "type": "record", "name": "MatchedSamples",
"fields": [{"doc": "", "type": "string", "name": "germlineSampleId"},
{"doc": "", "type": "string", "name": "tumorSampleId"}]}, "type":
"array"}, "name": "matchedSamples"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "cancerDemographics",
        "cancerSamples",
        "matchedSamples",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cancerDemographics': CancerDemographics,
            'cancerSamples': CancerSample,
            'matchedSamples': MatchedSamples,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'cancerDemographics': CancerDemographics,
            'cancerSamples': CancerSample,
            'matchedSamples': MatchedSamples,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'cancerDemographics', 'cancerSamples', 'matchedSamples'
    ]

    def __init__(self, **kwargs):
        self.cancerDemographics = kwargs.get(
            'cancerDemographics', None)
        self.cancerSamples = kwargs.get(
            'cancerSamples', None)
        self.matchedSamples = kwargs.get(
            'matchedSamples', None)


class CancerPertinentFinding(ProtocolElement):
    """
    Cancer Pertinent Findings
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CancerPertinentFinding", "fields": [{"doc": "", "type": {"fields":
[{"doc": "", "type": ["null", {"values": "string", "type": "map"}],
"name": "analyst"}, {"doc": "", "type": ["null", {"values": "string",
"type": "map"}], "name": "clinicalGeneticist"}, {"doc": "", "type":
"string", "name": "genomicsEngland"}, {"doc": "", "type": "string",
"name": "contactMail"}], "type": "record", "name": "Contact"}, "name":
"contact"}, {"doc": "", "type": {"items": {"fields": [{"doc": "",
"type": ["null", "string"], "name": "consultant"}, {"doc": "", "type":
"string", "name": "GMC"}, {"doc": "", "type": "string", "name":
"GMCmail"}], "type": "record", "name": "ClinicalResponsibility"},
"type": "array"}, "name": "clinicalResponsibility"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "Sequencing", "fields":
[{"doc": "", "type": "string", "name": "SequencingCentre"}, {"doc":
"", "type": "string", "name": "SequencingAddress"}, {"doc": "",
"type": ["null", "string"], "name": "AccreditationStatus"}, {"doc":
"", "type": ["null", "string"], "name": "AccreditationDate"}]},
"name": "sequencing"}, {"doc": "", "type": "string", "name":
"gELInterimId"}, {"doc": "", "type": {"fields": [{"doc": "", "type":
"string", "name": "reportID"}, {"doc": "", "type": "float", "name":
"reportDate"}], "type": "record", "name": "Tracking"}, "name":
"tracking"}, {"doc": "", "type": {"fields": [{"doc": "", "type":
["null", {"values": {"symbols": ["WuXiNextCODE", "Omicia",
"Congenica"], "type": "enum", "name": "Companies"}, "type": "map"}],
"name": "interpretationCompany"}, {"doc": "", "type": ["null",
{"values": "string", "type": "map"}], "name":
"interpretationRequestDate"}, {"doc": "", "type": ["null", {"values":
"string", "type": "map"}], "name": "interpretationRequestID"}],
"type": "record", "name": "InterpretationRequest"}, "name":
"interpretationRequest"}, {"doc": "", "type": {"fields": [{"doc": "",
"type": "string", "name": "gelFamilyId"}, {"doc": "", "type":
{"items": {"fields": [{"doc": "", "type": "string", "name":
"participantName"}, {"doc": "", "type": "string", "name":
"participantDOB"}, {"doc": "", "type": "string", "name": "NHSNumber"},
{"doc": "", "type": ["null", "string"], "name": "hospitalNumber"},
{"doc": "", "type": "string", "name": "gender"}, {"doc": "", "type":
["null", "string"], "name": "affectionStatus"}, {"doc": "", "type":
["null", "string"], "name": "relationshipToProband"}], "type":
"record", "name": "ParticipantInformation"}, "type": "array"}, "name":
"participants"}, {"doc": "", "type": ["null", "string"], "name":
"pedigreeFile"}], "type": "record", "name": "Pedigree"}, "name":
"pedigree"}, {"doc": "", "type": {"doc": "", "type": "record", "name":
"MatchedSamples", "fields": [{"doc": "", "type": "string", "name":
"germlineSampleId"}, {"doc": "", "type": "string", "name":
"tumorSampleId"}]}, "name": "matchedSamples"}, {"doc": "", "type":
{"doc": "", "type": "record", "name": "ConsentStatus", "fields":
[{"default": false, "doc": "", "type": "boolean", "name":
"programmeConsent"}, {"default": false, "doc": "", "type": "boolean",
"name": "primaryFindingConsent"}, {"default": false, "doc": "",
"type": "boolean", "name": "secondaryFindingConsent"}, {"default":
false, "doc": "", "type": "boolean", "name":
"carrierStatusConsent"}]}, "name": "consentStatus"}, {"doc": "",
"type": {"fields": [{"doc": "", "type": "string", "name":
"methodsVersion"}], "type": "record", "name": "MethodsVersion"},
"name": "methodsVersion"}, {"doc": "", "type": ["null", {"fields":
[{"doc": "", "type": ["null", "string"], "name": "consanguinity"},
{"doc": "", "type": ["null", {"values": {"symbols": ["A", "B", "C",
"D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "S", "R", "Z"],
"type": "enum", "name": "EthnicOrigin"}, "type": "map"}], "name":
"mothersEthnicOrigin"}, {"doc": "", "type": ["null", {"values":
"EthnicOrigin", "type": "map"}], "name": "fathersEthnicOrigin"},
{"doc": "", "type": ["null", "string"], "name":
"mothersOtherRelevantAncestry"}, {"doc": "", "type": ["null",
"string"], "name": "fathersOtherRelevantAncestry"}, {"doc": "",
"type": ["null", "string", {"values": {"symbols":
["Colorectal_Cancer", "Breast_and_or_Ovarian_Cancer",
"Ischaemic_Heart_Disease_or_Stroke", "Endocrine_Tumours"], "type":
"enum", "name": "FamilyHistory"}, "type": "map"}], "name":
"maternalFamilyHistory"}, {"doc": "", "type": ["null", "string",
{"values": "FamilyHistory", "type": "map"}], "name":
"paternalFamilyHistory"}], "type": "record", "name":
"AdditionalInformation"}], "name": "additionalInformation"}, {"doc":
"", "type": {"doc": "", "type": "record", "name": "CancerDisclaimers",
"fields": [{"doc": "", "type": "string", "name":
"CancerResearchDisclaimer"}, {"doc": "", "type": "string", "name":
"reportContext"}]}, "name": "cancerDisclaimers"}, {"doc": "", "type":
{"items": {"fields": [{"doc": "", "type": "string", "name":
"Cancer"}], "type": "record", "name": "RecruitedCancer"}, "type":
"array"}, "name": "recruitedCancer"}, {"doc": "", "type": ["null",
{"fields": [{"doc": "", "type": "string", "name": "genePanelName"},
{"doc": "", "type": "string", "name": "genePanelVersion"}], "type":
"record", "name": "GenePanels"}], "name": "genePanels"}, {"doc": "",
"type": ["null", {"items": {"doc": "", "type": "record", "name":
"CandidateVariants", "fields": [{"doc": "", "type": ["null", "int"],
"name": "tier"}, {"doc": "", "type": "string", "name":
"HGNCGeneSymbol"}, {"doc": "", "type": "string", "name":
"GRCh37coordinates"}, {"doc": "", "type": ["null", "int"], "name":
"VariantSize"}, {"doc": "", "type": ["null", "string"], "name":
"transcriptID"}, {"doc": "", "type": ["null", "string"], "name":
"cDNAChange"}, {"doc": "", "type": ["null", "string"], "name":
"proteinChange"}, {"doc": "", "type": ["null", "string"], "name":
"predictedConsequence"}, {"doc": "", "type": ["null", "string"],
"name": "rsID"}, {"doc": "", "type": "string", "name":
"depthAtPosition"}, {"doc": "", "type": ["null", "string"], "name":
"allelicFraction"}, {"doc": "", "type": "string", "name": "genotype"},
{"doc": "", "type": ["null", "string"], "name": "clinVarAccession"},
{"doc": "", "type": ["null", {"values": "double", "type": "map"}],
"name": "alleleFreq"}, {"doc": "", "type": "string", "name":
"modeOfInheritanceVariant"}, {"doc": "", "type": ["null", "string"],
"name": "modeOfInheritanceGene"}, {"doc": "", "type": ["null",
"string"], "name": "knownPhenotype"}]}, "type": "array"}], "name":
"candidateVariants"}, {"doc": "", "type": ["null", {"fields": [{"doc":
"", "type": ["null", "string"], "name": "interventionCategory"},
{"doc": "", "type": ["null", "string"], "name": "clinicalTrials"},
{"doc": "", "type": ["null", "string"], "name": "pharmacogenetic"}],
"type": "record", "name": "ActionableInformation"}], "name":
"actionableInformation"}, {"doc": "", "type": ["null", {"fields":
[{"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"File", "fields": [{"doc": "", "type": ["null", "string", {"items":
"string", "type": "array"}], "name": "SampleId"}, {"doc": "", "type":
"string", "name": "URIFile"}]}, "type": "array"}, "name":
"circusPlot"}, {"doc": "", "type": {"items": "File", "type": "array"},
"name": "copyNumberPlot"}, {"doc": "", "type": {"items": "File",
"type": "array"}, "name": "FusionGenes"}], "type": "record", "name":
"CancerMetrics"}], "name": "cancerMetrics"}, {"doc": "", "type":
["null", {"fields": [{"doc": "", "type": {"items": "File", "type":
"array"}, "name": "tumourPurity"}, {"doc": "", "type": {"items":
"File", "type": "array"}, "name": "tumourPloidy"}], "type": "record",
"name": "Tumour"}], "name": "tumour"}, {"doc": "", "type": ["null",
{"fields": [{"doc": "", "type": {"items": "File", "type": "array"},
"name": "sampleProvenance"}, {"doc": "", "type": {"items": "File",
"type": "array"}, "name": "concordanceChecks"}, {"doc": "", "type":
["null", {"items": "File", "type": "array"}], "name":
"pathogenDetection"}, {"doc": "", "type": ["null", {"items": "File",
"type": "array"}], "name": "crossSpeciesContamination"}], "type":
"record", "name": "Provenance"}], "name": "provenance"}, {"doc": "",
"type": ["null", {"fields": [{"doc": "", "type": {"items": "File",
"type": "array"}, "name": "genomeWideCoverage15x"}, {"doc": "",
"type": {"items": "File", "type": "array"}, "name":
"genomeWideCoverage30"}, {"doc": "", "type": ["null", {"items":
"File", "type": "array"}], "name": "genePanelCoveragePanel"}, {"doc":
"", "type": ["null", {"items": "File", "type": "array"}], "name":
"genePanelCoverageGenes"}], "type": "record", "name":
"CoverageMetrics"}], "name": "coverageMetrics"}, {"doc": "", "type":
["null", {"fields": [{"doc": "", "type": ["null", {"items": "File",
"type": "array"}], "name": "LOH"}, {"doc": "", "type": ["null",
{"items": "File", "type": "array"}], "name": "ROH"}, {"doc": "",
"type": ["null", {"items": "File", "type": "array"}], "name": "UPD"}],
"type": "record", "name": "QualityControl"}], "name":
"qualityControl"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "actionableInformation",
        "additionalInformation",
        "cancerDisclaimers",
        "cancerMetrics",
        "candidateVariants",
        "clinicalResponsibility",
        "consentStatus",
        "contact",
        "coverageMetrics",
        "gELInterimId",
        "genePanels",
        "interpretationRequest",
        "matchedSamples",
        "methodsVersion",
        "pedigree",
        "provenance",
        "qualityControl",
        "recruitedCancer",
        "sequencing",
        "tracking",
        "tumour",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'actionableInformation': ActionableInformation,
            'additionalInformation': AdditionalInformation,
            'cancerDisclaimers': CancerDisclaimers,
            'cancerMetrics': CancerMetrics,
            'clinicalResponsibility': ClinicalResponsibility,
            'consentStatus': ConsentStatus,
            'contact': Contact,
            'coverageMetrics': CoverageMetrics,
            'genePanels': GenePanels,
            'interpretationRequest': InterpretationRequest,
            'matchedSamples': MatchedSamples,
            'methodsVersion': MethodsVersion,
            'pedigree': Pedigree,
            'provenance': Provenance,
            'qualityControl': QualityControl,
            'recruitedCancer': RecruitedCancer,
            'sequencing': Sequencing,
            'tracking': Tracking,
            'tumour': Tumour,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'actionableInformation': ActionableInformation,
            'additionalInformation': AdditionalInformation,
            'cancerDisclaimers': CancerDisclaimers,
            'cancerMetrics': CancerMetrics,
            'clinicalResponsibility': ClinicalResponsibility,
            'consentStatus': ConsentStatus,
            'contact': Contact,
            'coverageMetrics': CoverageMetrics,
            'genePanels': GenePanels,
            'interpretationRequest': InterpretationRequest,
            'matchedSamples': MatchedSamples,
            'methodsVersion': MethodsVersion,
            'pedigree': Pedigree,
            'provenance': Provenance,
            'qualityControl': QualityControl,
            'recruitedCancer': RecruitedCancer,
            'sequencing': Sequencing,
            'tracking': Tracking,
            'tumour': Tumour,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'actionableInformation', 'additionalInformation',
        'cancerDisclaimers', 'cancerMetrics', 'candidateVariants',
        'clinicalResponsibility', 'consentStatus', 'contact',
        'coverageMetrics', 'gELInterimId', 'genePanels',
        'interpretationRequest', 'matchedSamples', 'methodsVersion',
        'pedigree', 'provenance', 'qualityControl', 'recruitedCancer',
        'sequencing', 'tracking', 'tumour'
    ]

    def __init__(self, **kwargs):
        self.actionableInformation = kwargs.get(
            'actionableInformation', None)
        self.additionalInformation = kwargs.get(
            'additionalInformation', None)
        self.cancerDisclaimers = kwargs.get(
            'cancerDisclaimers', None)
        self.cancerMetrics = kwargs.get(
            'cancerMetrics', None)
        self.candidateVariants = kwargs.get(
            'candidateVariants', None)
        self.clinicalResponsibility = kwargs.get(
            'clinicalResponsibility', None)
        self.consentStatus = kwargs.get(
            'consentStatus', None)
        self.contact = kwargs.get(
            'contact', None)
        self.coverageMetrics = kwargs.get(
            'coverageMetrics', None)
        self.gELInterimId = kwargs.get(
            'gELInterimId', 'None')
        self.genePanels = kwargs.get(
            'genePanels', None)
        self.interpretationRequest = kwargs.get(
            'interpretationRequest', None)
        self.matchedSamples = kwargs.get(
            'matchedSamples', None)
        self.methodsVersion = kwargs.get(
            'methodsVersion', None)
        self.pedigree = kwargs.get(
            'pedigree', None)
        self.provenance = kwargs.get(
            'provenance', None)
        self.qualityControl = kwargs.get(
            'qualityControl', None)
        self.recruitedCancer = kwargs.get(
            'recruitedCancer', None)
        self.sequencing = kwargs.get(
            'sequencing', None)
        self.tracking = kwargs.get(
            'tracking', None)
        self.tumour = kwargs.get(
            'tumour', None)


class CancerSample(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CancerSample", "fields": [{"doc": "", "type": "string", "name":
"sampleId"}, {"doc": "", "type": {"symbols": ["germline", "tumor"],
"type": "enum", "name": "SampleType"}, "name": "sampleType"}, {"doc":
"", "type": ["null", "string"], "name": "source"}, {"doc": "", "type":
["null", {"symbols": ["FFPE", "FF", "Unknown", "LEUK", "GL"], "type":
"enum", "name": "PreservationMethod"}], "name": "preservationMethod"},
{"doc": "", "type": ["null", {"symbols": ["primary", "metastasis"],
"type": "enum", "name": "Phase"}], "name": "phase"}, {"doc": "",
"type": ["null", {"symbols": ["resection", "biopsy"], "type": "enum",
"name": "Method"}], "name": "method"}, {"doc": "", "type": ["null",
"double"], "name": "cellularity"}, {"doc": "", "type": ["null",
"double"], "name": "tumorContent"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "cellularity",
        "method",
        "phase",
        "preservationMethod",
        "sampleId",
        "sampleType",
        "source",
        "tumorContent",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'cellularity', 'method', 'phase', 'preservationMethod',
        'sampleId', 'sampleType', 'source', 'tumorContent'
    ]

    def __init__(self, **kwargs):
        self.cellularity = kwargs.get(
            'cellularity', None)
        self.method = kwargs.get(
            'method', None)
        self.phase = kwargs.get(
            'phase', None)
        self.preservationMethod = kwargs.get(
            'preservationMethod', None)
        self.sampleId = kwargs.get(
            'sampleId', 'None')
        self.sampleType = kwargs.get(
            'sampleType', None)
        self.source = kwargs.get(
            'source', None)
        self.tumorContent = kwargs.get(
            'tumorContent', None)


class CandidateVariants(ProtocolElement):
    """
    The candidate variant from the perspective of the proband
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CandidateVariants", "fields": [{"doc": "", "type": ["null", "int"],
"name": "tier"}, {"doc": "", "type": "string", "name":
"HGNCGeneSymbol"}, {"doc": "", "type": "string", "name":
"GRCh37coordinates"}, {"doc": "", "type": ["null", "int"], "name":
"VariantSize"}, {"doc": "", "type": ["null", "string"], "name":
"transcriptID"}, {"doc": "", "type": ["null", "string"], "name":
"cDNAChange"}, {"doc": "", "type": ["null", "string"], "name":
"proteinChange"}, {"doc": "", "type": ["null", "string"], "name":
"predictedConsequence"}, {"doc": "", "type": ["null", "string"],
"name": "rsID"}, {"doc": "", "type": "string", "name":
"depthAtPosition"}, {"doc": "", "type": ["null", "string"], "name":
"allelicFraction"}, {"doc": "", "type": "string", "name": "genotype"},
{"doc": "", "type": ["null", "string"], "name": "clinVarAccession"},
{"doc": "", "type": ["null", {"values": "double", "type": "map"}],
"name": "alleleFreq"}, {"doc": "", "type": "string", "name":
"modeOfInheritanceVariant"}, {"doc": "", "type": ["null", "string"],
"name": "modeOfInheritanceGene"}, {"doc": "", "type": ["null",
"string"], "name": "knownPhenotype"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "GRCh37coordinates",
        "HGNCGeneSymbol",
        "VariantSize",
        "alleleFreq",
        "allelicFraction",
        "cDNAChange",
        "clinVarAccession",
        "depthAtPosition",
        "genotype",
        "knownPhenotype",
        "modeOfInheritanceGene",
        "modeOfInheritanceVariant",
        "predictedConsequence",
        "proteinChange",
        "rsID",
        "tier",
        "transcriptID",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'GRCh37coordinates', 'HGNCGeneSymbol', 'VariantSize',
        'alleleFreq', 'allelicFraction', 'cDNAChange',
        'clinVarAccession', 'depthAtPosition', 'genotype',
        'knownPhenotype', 'modeOfInheritanceGene',
        'modeOfInheritanceVariant', 'predictedConsequence',
        'proteinChange', 'rsID', 'tier', 'transcriptID'
    ]

    def __init__(self, **kwargs):
        self.GRCh37coordinates = kwargs.get(
            'GRCh37coordinates', 'None')
        self.HGNCGeneSymbol = kwargs.get(
            'HGNCGeneSymbol', 'None')
        self.VariantSize = kwargs.get(
            'VariantSize', None)
        self.alleleFreq = kwargs.get(
            'alleleFreq', None)
        self.allelicFraction = kwargs.get(
            'allelicFraction', None)
        self.cDNAChange = kwargs.get(
            'cDNAChange', None)
        self.clinVarAccession = kwargs.get(
            'clinVarAccession', None)
        self.depthAtPosition = kwargs.get(
            'depthAtPosition', 'None')
        self.genotype = kwargs.get(
            'genotype', 'None')
        self.knownPhenotype = kwargs.get(
            'knownPhenotype', None)
        self.modeOfInheritanceGene = kwargs.get(
            'modeOfInheritanceGene', None)
        self.modeOfInheritanceVariant = kwargs.get(
            'modeOfInheritanceVariant', 'None')
        self.predictedConsequence = kwargs.get(
            'predictedConsequence', None)
        self.proteinChange = kwargs.get(
            'proteinChange', None)
        self.rsID = kwargs.get(
            'rsID', None)
        self.tier = kwargs.get(
            'tier', None)
        self.transcriptID = kwargs.get(
            'transcriptID', None)


class ChiSquare1KGenomesPhase3Pop(ProtocolElement):
    """
    Chi-square test for goodness of fit of this sample to 1000 Genomes
    Phase 3 populations
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"ChiSquare1KGenomesPhase3Pop", "fields": [{"doc": "", "type":
{"symbols": ["AFR", "AMR", "EAS", "EUR", "SAS"], "doc": "", "type":
"enum", "name": "KGSuperPopCategory"}, "name": "kGSuperPopCategory"},
{"doc": "", "type": ["null", {"symbols": ["ACB", "ASW", "BEB", "CDX",
"CEU", "CHB", "CHS", "CLM", "ESN", "FIN", "GBR", "GIH", "GWD", "IBS",
"ITU", "JPT", "KHV", "LWK", "MSL", "MXL", "PEL", "PJL", "PUR", "STU",
"TSI", "YRI"], "doc": "", "type": "enum", "name": "KGPopCategory"}],
"name": "kGPopCategory"}, {"doc": "", "type": "float", "name":
"chiSquare"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "chiSquare",
        "kGPopCategory",
        "kGSuperPopCategory",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'chiSquare', 'kGPopCategory', 'kGSuperPopCategory'
    ]

    def __init__(self, **kwargs):
        self.chiSquare = kwargs.get(
            'chiSquare', None)
        self.kGPopCategory = kwargs.get(
            'kGPopCategory', None)
        self.kGSuperPopCategory = kwargs.get(
            'kGSuperPopCategory', None)


class ClinicalResponsibility(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"ClinicalResponsibility", "fields": [{"doc": "", "type": ["null",
"string"], "name": "consultant"}, {"doc": "", "type": "string",
"name": "GMC"}, {"doc": "", "type": "string", "name": "GMCmail"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "GMC",
        "GMCmail",
        "consultant",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'GMC', 'GMCmail', 'consultant'
    ]

    def __init__(self, **kwargs):
        self.GMC = kwargs.get(
            'GMC', 'None')
        self.GMCmail = kwargs.get(
            'GMCmail', 'None')
        self.consultant = kwargs.get(
            'consultant', None)


class CommonQualityControl(ProtocolElement):
    """
    Unique to case log
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CommonQualityControl", "fields": [{"doc": "", "type": ["null",
{"items": {"doc": "", "type": "record", "name": "File", "fields":
[{"doc": "", "type": ["null", "string", {"items": "string", "type":
"array"}], "name": "SampleId"}, {"doc": "", "type": "string", "name":
"URIFile"}]}, "type": "array"}], "name": "mendelErrors"}, {"doc": "",
"type": ["null", {"items": "File", "type": "array"}], "name":
"sexPrediction"}, {"doc": "", "type": ["null", {"items": "File",
"type": "array"}], "name": "relatednessCheck"}, {"doc": "", "type":
["null", {"items": "File", "type": "array"}], "name":
"humanContminationFraction"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "humanContminationFraction",
        "mendelErrors",
        "relatednessCheck",
        "sexPrediction",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'humanContminationFraction', 'mendelErrors',
        'relatednessCheck', 'sexPrediction'
    ]

    def __init__(self, **kwargs):
        self.humanContminationFraction = kwargs.get(
            'humanContminationFraction', None)
        self.mendelErrors = kwargs.get(
            'mendelErrors', None)
        self.relatednessCheck = kwargs.get(
            'relatednessCheck', None)
        self.sexPrediction = kwargs.get(
            'sexPrediction', None)


class Companies(object):
    """
    No documentation
    """
    WuXiNextCODE = "WuXiNextCODE"
    Omicia = "Omicia"
    Congenica = "Congenica"


class ComplexGeneticPhenomena(object):
    """
    No documentation
    """
    mosaicism = "mosaicism"
    monosomy = "monosomy"
    disomy = "disomy"
    uniparental_disomy = "uniparental_disomy"
    trisomy = "trisomy"
    other_aneuploidy = "other_aneuploidy"


class ConsentStatus(ProtocolElement):
    """
    Consent Status
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"ConsentStatus", "fields": [{"default": false, "doc": "", "type":
"boolean", "name": "programmeConsent"}, {"default": false, "doc": "",
"type": "boolean", "name": "primaryFindingConsent"}, {"default":
false, "doc": "", "type": "boolean", "name":
"secondaryFindingConsent"}, {"default": false, "doc": "", "type":
"boolean", "name": "carrierStatusConsent"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {}

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'carrierStatusConsent', 'primaryFindingConsent',
        'programmeConsent', 'secondaryFindingConsent'
    ]

    def __init__(self, **kwargs):
        self.carrierStatusConsent = kwargs.get(
            'carrierStatusConsent', False)
        self.primaryFindingConsent = kwargs.get(
            'primaryFindingConsent', False)
        self.programmeConsent = kwargs.get(
            'programmeConsent', False)
        self.secondaryFindingConsent = kwargs.get(
            'secondaryFindingConsent', False)


class Contact(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"Contact", "fields": [{"doc": "", "type": ["null", {"values":
"string", "type": "map"}], "name": "analyst"}, {"doc": "", "type":
["null", {"values": "string", "type": "map"}], "name":
"clinicalGeneticist"}, {"doc": "", "type": "string", "name":
"genomicsEngland"}, {"doc": "", "type": "string", "name":
"contactMail"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "analyst",
        "clinicalGeneticist",
        "contactMail",
        "genomicsEngland",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'analyst', 'clinicalGeneticist', 'contactMail',
        'genomicsEngland'
    ]

    def __init__(self, **kwargs):
        self.analyst = kwargs.get(
            'analyst', None)
        self.clinicalGeneticist = kwargs.get(
            'clinicalGeneticist', None)
        self.contactMail = kwargs.get(
            'contactMail', 'None')
        self.genomicsEngland = kwargs.get(
            'genomicsEngland', 'None')


class CoverageMetrics(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"CoverageMetrics", "fields": [{"doc": "", "type": {"items": {"doc":
"", "type": "record", "name": "File", "fields": [{"doc": "", "type":
["null", "string", {"items": "string", "type": "array"}], "name":
"SampleId"}, {"doc": "", "type": "string", "name": "URIFile"}]},
"type": "array"}, "name": "genomeWideCoverage15x"}, {"doc": "",
"type": {"items": "File", "type": "array"}, "name":
"genomeWideCoverage30"}, {"doc": "", "type": ["null", {"items":
"File", "type": "array"}], "name": "genePanelCoveragePanel"}, {"doc":
"", "type": ["null", {"items": "File", "type": "array"}], "name":
"genePanelCoverageGenes"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "genePanelCoverageGenes",
        "genePanelCoveragePanel",
        "genomeWideCoverage15x",
        "genomeWideCoverage30",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'genomeWideCoverage15x': File,
            'genomeWideCoverage30': File,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'genomeWideCoverage15x': File,
            'genomeWideCoverage30': File,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'genePanelCoverageGenes', 'genePanelCoveragePanel',
        'genomeWideCoverage15x', 'genomeWideCoverage30'
    ]

    def __init__(self, **kwargs):
        self.genePanelCoverageGenes = kwargs.get(
            'genePanelCoverageGenes', None)
        self.genePanelCoveragePanel = kwargs.get(
            'genePanelCoveragePanel', None)
        self.genomeWideCoverage15x = kwargs.get(
            'genomeWideCoverage15x', None)
        self.genomeWideCoverage30 = kwargs.get(
            'genomeWideCoverage30', None)


class Disorder(ProtocolElement):
    """
    This is quite GEL specific. This is the way is stored in
    ModelCatalogue and PanelApp. Currently all specific disease titles
    are assigned to a disease subgroup so really only specificDisease
    needs to be completed but we add the others for generality
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"Disorder", "fields": [{"doc": "", "type": ["null", "string"], "name":
"diseaseGroup"}, {"doc": "", "type": ["null", "string"], "name":
"diseaseSubGroup"}, {"doc": "", "type": ["null", "string"], "name":
"specificDisease"}, {"doc": "", "type": ["null", "int"], "name":
"ageOfOnset"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "ageOfOnset",
        "diseaseGroup",
        "diseaseSubGroup",
        "specificDisease",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'ageOfOnset', 'diseaseGroup', 'diseaseSubGroup',
        'specificDisease'
    ]

    def __init__(self, **kwargs):
        self.ageOfOnset = kwargs.get(
            'ageOfOnset', None)
        self.diseaseGroup = kwargs.get(
            'diseaseGroup', None)
        self.diseaseSubGroup = kwargs.get(
            'diseaseSubGroup', None)
        self.specificDisease = kwargs.get(
            'specificDisease', None)


class EthnicCategory(object):
    """
    This is the list of ethnics in ONS16  * `D`:  Mixed: White and
    Black Caribbean * `E`:  Mixed: White and Black African * `F`:
    Mixed: White and Asian * `G`:  Mixed: Any other mixed background *
    `A`:  White: British * `B`:  White: Irish * `C`:  White: Any other
    White background * `L`:  Asian or Asian British: Any other Asian
    background * `M`:  Black or Black British: Caribbean * `N`:  Black
    or Black British: African * `H`:  Asian or Asian British: Indian *
    `J`:  Asian or Asian British: Pakistani * `K`:  Asian or Asian
    British: Bangladeshi * `P`:  Black or Black British: Any other
    Black background * `S`:  Other Ethnic Groups: Any other ethnic
    group * `R`:  Other Ethnic Groups: Chinese * `Z`:  Not stated
    """
    D = "D"
    E = "E"
    F = "F"
    G = "G"
    A = "A"
    B = "B"
    C = "C"
    L = "L"
    M = "M"
    N = "N"
    H = "H"
    J = "J"
    K = "K"
    P = "P"
    S = "S"
    R = "R"
    Z = "Z"


class EthnicOrigin(object):
    """
    No documentation
    """
    A = "A"
    B = "B"
    C = "C"
    D = "D"
    E = "E"
    F = "F"
    G = "G"
    H = "H"
    J = "J"
    K = "K"
    L = "L"
    M = "M"
    N = "N"
    P = "P"
    S = "S"
    R = "R"
    Z = "Z"


class FamilyHistory(object):
    """
    No documentation
    """
    Colorectal_Cancer = "Colorectal_Cancer"
    Breast_and_or_Ovarian_Cancer = "Breast_and_or_Ovarian_Cancer"
    Ischaemic_Heart_Disease_or_Stroke = "Ischaemic_Heart_Disease_or_Stroke"
    Endocrine_Tumours = "Endocrine_Tumours"


class File(ProtocolElement):
    """
    This defines a file This Record is defined by the sampleID and a
    URI Currently SampleID can be a single String or an array of
    strings if multiple samples are associated with the same file
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name": "File",
"fields": [{"doc": "", "type": ["null", "string", {"items": "string",
"type": "array"}], "name": "SampleId"}, {"doc": "", "type": "string",
"name": "URIFile"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "SampleId",
        "URIFile",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'SampleId', 'URIFile'
    ]

    def __init__(self, **kwargs):
        self.SampleId = kwargs.get(
            'SampleId', None)
        self.URIFile = kwargs.get(
            'URIFile', 'None')


class GenePanels(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"GenePanels", "fields": [{"doc": "", "type": "string", "name":
"genePanelName"}, {"doc": "", "type": "string", "name":
"genePanelVersion"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "genePanelName",
        "genePanelVersion",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'genePanelName', 'genePanelVersion'
    ]

    def __init__(self, **kwargs):
        self.genePanelName = kwargs.get(
            'genePanelName', 'None')
        self.genePanelVersion = kwargs.get(
            'genePanelVersion', 'None')


class HpoTerm(ProtocolElement):
    """
    This defines an HPO term and its modifiers (possibly multiple) If
    HPO term presence is unknown we don't have a entry on the list
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"HpoTerm", "fields": [{"doc": "", "type": "string", "name": "term"},
{"doc": "", "type": "boolean", "name": "termPresence"}, {"doc": "",
"type": ["null", {"values": "string", "type": "map"}], "name":
"modifiers"}, {"doc": "", "type": ["null", "int"], "name":
"ageOfOnset"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "ageOfOnset",
        "modifiers",
        "term",
        "termPresence",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'ageOfOnset', 'modifiers', 'term', 'termPresence'
    ]

    def __init__(self, **kwargs):
        self.ageOfOnset = kwargs.get(
            'ageOfOnset', None)
        self.modifiers = kwargs.get(
            'modifiers', None)
        self.term = kwargs.get(
            'term', 'None')
        self.termPresence = kwargs.get(
            'termPresence', None)


class InterpretationAuthorisation(ProtocolElement):
    """
    Unique to case log
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"InterpretationAuthorisation", "fields": [{"doc": "", "type": ["null",
"string"], "name": "interpretationAuthorisationDate"}, {"doc": "",
"type": ["null", "string"], "name": "nameOfAuthoriser"}, {"doc": "",
"type": ["null", {"items": {"doc": "", "type": "record", "name":
"ReportEvents", "fields": [{"doc": "", "type": ["null", "string"],
"name": "reportEventId"}, {"doc": "", "type": ["null", {"symbols":
["approved", "rejected"], "type": "enum", "name":
"ReportEventStatus"}], "name": "reportEventStatus"}, {"doc": "",
"type": ["null", "string"], "name": "authorisationJustification"}]},
"type": "array"}], "name": "reportEvents"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "interpretationAuthorisationDate",
        "nameOfAuthoriser",
        "reportEvents",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'interpretationAuthorisationDate', 'nameOfAuthoriser',
        'reportEvents'
    ]

    def __init__(self, **kwargs):
        self.interpretationAuthorisationDate = kwargs.get(
            'interpretationAuthorisationDate', None)
        self.nameOfAuthoriser = kwargs.get(
            'nameOfAuthoriser', None)
        self.reportEvents = kwargs.get(
            'reportEvents', None)


class InterpretationRequest(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"InterpretationRequest", "fields": [{"doc": "", "type": ["null",
{"values": {"symbols": ["WuXiNextCODE", "Omicia", "Congenica"],
"type": "enum", "name": "Companies"}, "type": "map"}], "name":
"interpretationCompany"}, {"doc": "", "type": ["null", {"values":
"string", "type": "map"}], "name": "interpretationRequestDate"},
{"doc": "", "type": ["null", {"values": "string", "type": "map"}],
"name": "interpretationRequestID"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "interpretationCompany",
        "interpretationRequestDate",
        "interpretationRequestID",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'interpretationCompany', 'interpretationRequestDate',
        'interpretationRequestID'
    ]

    def __init__(self, **kwargs):
        self.interpretationCompany = kwargs.get(
            'interpretationCompany', None)
        self.interpretationRequestDate = kwargs.get(
            'interpretationRequestDate', None)
        self.interpretationRequestID = kwargs.get(
            'interpretationRequestID', None)


class InterpretationRequestRD(ProtocolElement):
    """
    This record represents basic information for this report
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"InterpretationRequestRD", "fields": [{"doc": "", "type": "string",
"name": "InterpretationRequestID"}, {"default": "GRCh37.p13", "doc":
"", "type": "string", "name": "genomeAssemblyVersion"}, {"doc": "",
"type": "int", "name": "InterpretationRequestVersion"}, {"default":
false, "doc": "", "type": "boolean", "name": "interpretGenome"},
{"doc": "", "type": {"items": "string", "type": "array"}, "name":
"workspace"}, {"doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "File", "fields": [{"doc": "", "type": ["null",
"string", {"items": "string", "type": "array"}], "name": "SampleId"},
{"doc": "", "type": "string", "name": "URIFile"}]}, "type": "array"},
"name": "BAMs"}, {"doc": "", "type": {"items": "File", "type":
"array"}, "name": "gVCFs"}, {"doc": "", "type": {"items": "File",
"type": "array"}, "name": "VCFs"}, {"doc": "", "type": ["null",
{"items": "File", "type": "array"}], "name": "bigWigs"}, {"doc": "",
"type": ["null", "File"], "name": "pedigreeDiagram"}, {"doc": "",
"type": ["null", "File"], "name": "annotationFile"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "Pedigree", "fields":
[{"doc": "", "type": "string", "name": "gelFamilyId"}, {"type":
{"items": {"doc": "", "type": "record", "name": "RDParticipant",
"fields": [{"doc": "", "type": "int", "name": "pedigreeId"}, {"doc":
"", "type": "boolean", "name": "isProband"}, {"doc": "", "type":
["null", "string"], "name": "gelId"}, {"doc": "", "type": "string",
"name": "gelFamilyId"}, {"doc": "", "type": {"symbols": ["male",
"female", "undetermined"], "doc": "", "type": "enum", "name": "Sex"},
"name": "sex"}, {"doc": "", "type": ["null", "int"], "name":
"fatherId"}, {"doc": "", "type": ["null", "int"], "name": "motherId"},
{"doc": "", "type": ["null", "int"], "name": "twinGroup"}, {"doc": "",
"type": ["null", {"symbols": ["yes", "no", "unknown"], "doc": "",
"type": "enum", "name": "TernaryOption"}], "name": "monozygotic"},
{"doc": "", "type": {"symbols": ["not_adopted", "adoptedin",
"adoptedout"], "doc": "", "type": "enum", "name": "AdoptedStatus"},
"name": "adoptedStatus"}, {"doc": "", "type": {"symbols": ["alive",
"aborted", "deceased", "unborn", "stillborn", "miscarriage"], "doc":
"", "type": "enum", "name": "LifeStatus"}, "name": "lifeStatus"},
{"doc": "", "type": "TernaryOption", "name": "consanguineousParents"},
{"doc": "", "type": ["null", "string"], "name":
"consanguineousPopulation"}, {"doc": "", "type": {"symbols":
["unaffected", "affected", "unknown"], "doc": "", "type": "enum",
"name": "AffectionStatus"}, "name": "affectionStatus"}, {"doc": "",
"type": {"items": {"doc": "", "type": "record", "name": "Disorder",
"fields": [{"doc": "", "type": ["null", "string"], "name":
"diseaseGroup"}, {"doc": "", "type": ["null", "string"], "name":
"diseaseSubGroup"}, {"doc": "", "type": ["null", "string"], "name":
"specificDisease"}, {"doc": "", "type": ["null", "int"], "name":
"ageOfOnset"}]}, "type": "array"}, "name": "disorderList"}, {"doc":
"", "type": {"items": {"doc": "", "type": "record", "name": "HpoTerm",
"fields": [{"doc": "", "type": "string", "name": "term"}, {"doc": "",
"type": "boolean", "name": "termPresence"}, {"doc": "", "type":
["null", {"values": "string", "type": "map"}], "name": "modifiers"},
{"doc": "", "type": ["null", "int"], "name": "ageOfOnset"}]}, "type":
"array"}, "name": "hpoTermList"}, {"doc": "", "type": {"fields":
[{"doc": "", "type": ["null", {"symbols": ["D", "E", "F", "G", "A",
"B", "C", "L", "M", "N", "H", "J", "K", "P", "S", "R", "Z"], "doc":
"", "type": "enum", "name": "EthnicCategory"}], "name":
"mothersEthnicOrigin"}, {"doc": "", "type": ["null", "string"],
"name": "mothersOtherRelevantAncestry"}, {"doc": "", "type": ["null",
"EthnicCategory"], "name": "fathersEthnicOrigin"}, {"doc": "", "type":
["null", "string"], "name": "fathersOtherRelevantAncestry"}, {"doc":
"", "type": ["null", {"items": {"doc": "", "type": "record", "name":
"ChiSquare1KGenomesPhase3Pop", "fields": [{"doc": "", "type":
{"symbols": ["AFR", "AMR", "EAS", "EUR", "SAS"], "doc": "", "type":
"enum", "name": "KGSuperPopCategory"}, "name": "kGSuperPopCategory"},
{"doc": "", "type": ["null", {"symbols": ["ACB", "ASW", "BEB", "CDX",
"CEU", "CHB", "CHS", "CLM", "ESN", "FIN", "GBR", "GIH", "GWD", "IBS",
"ITU", "JPT", "KHV", "LWK", "MSL", "MXL", "PEL", "PJL", "PUR", "STU",
"TSI", "YRI"], "doc": "", "type": "enum", "name": "KGPopCategory"}],
"name": "kGPopCategory"}, {"doc": "", "type": "float", "name":
"chiSquare"}]}, "type": "array"}], "name":
"chiSquare1KGenomesPhase3Pop"}], "type": "record", "name":
"Ancestries"}, "name": "ancestries"}, {"default": "v4.2", "doc": "",
"type": "string", "name": "dataModelCatalogueVersion"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "ConsentStatus",
"fields": [{"default": false, "doc": "", "type": "boolean", "name":
"programmeConsent"}, {"default": false, "doc": "", "type": "boolean",
"name": "primaryFindingConsent"}, {"default": false, "doc": "",
"type": "boolean", "name": "secondaryFindingConsent"}, {"default":
false, "doc": "", "type": "boolean", "name":
"carrierStatusConsent"}]}, "name": "consentStatus"}, {"doc": "",
"type": ["null", {"items": "string", "type": "array"}], "name":
"samples"}, {"doc": "", "type": ["null", {"values": "string", "type":
"map"}], "name": "additionalInformation"}]}, "type": "array"}, "name":
"participants"}]}, "name": "pedigree"}, {"doc": "", "type": ["null",
"File"], "name": "inbreedingCoefficientEstimates"}, {"doc": "",
"type": ["null", {"symbols": ["mosaicism", "monosomy", "disomy",
"uniparental_disomy", "trisomy", "other_aneuploidy"], "type": "enum",
"name": "ComplexGeneticPhenomena"}], "name":
"complexGeneticPhenomena"}, {"doc": "", "type": {"symbols":
["monoallelic", "monoallelic_not_imprinted",
"monoallelic_maternally_imprinted",
"monoallelic_paternally_imprinted", "biallelic",
"monoallelic_and_biallelic", "monoallelic_and_more_severe_biallelic",
"xlinked_biallelic", "xlinked_monoallelic", "mitochondrial",
"unknown"], "doc": "", "type": "enum", "name": "ModeOfInheritance"},
"name": "modeOfInheritance"}, {"doc": "", "type": ["null", {"items":
{"doc": "", "type": "record", "name": "VirtualPanel", "fields":
[{"doc": "", "type": "string", "name": "specificDiseaseTitle"},
{"doc": "", "type": "string", "name": "panelVersion"}, {"doc": "",
"type": "string", "name": "ensemblVersion"}, {"doc": "", "type":
"string", "name": "dataModelCatalogueVersion"}, {"doc": "", "type":
{"items": "string", "type": "array"}, "name": "geneIds"}, {"doc": "",
"type": ["null", {"items": "string", "type": "array"}], "name":
"Transcripts"}, {"doc": "", "type": ["null", "File"], "name":
"relevantRegions"}, {"doc": "", "type": ["null", "File"], "name":
"clinicalRelevantVariants"}]}, "type": "array"}], "name":
"virtualPanel"}, {"doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "OtherFamilyHistory", "fields": [{"doc": "", "type":
["null", {"items": "string", "type": "array"}], "name":
"maternalFamilyHistory"}, {"doc": "", "type": ["null", {"items":
"string", "type": "array"}], "name": "paternalFamilyHistory"}]}],
"name": "otherFamilyHistory"}, {"doc": "", "type": "string", "name":
"analysisReturnURI"}, {"default": "1", "doc": "", "type": "string",
"name": "analysisVersion"}, {"doc": "", "type": ["null", {"values":
"string", "type": "map"}], "name": "additionalInfo"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "BAMs",
        "InterpretationRequestID",
        "InterpretationRequestVersion",
        "VCFs",
        "additionalInfo",
        "analysisReturnURI",
        "annotationFile",
        "bigWigs",
        "complexGeneticPhenomena",
        "gVCFs",
        "inbreedingCoefficientEstimates",
        "modeOfInheritance",
        "otherFamilyHistory",
        "pedigree",
        "pedigreeDiagram",
        "virtualPanel",
        "workspace",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'BAMs': File,
            'VCFs': File,
            'annotationFile': File,
            'gVCFs': File,
            'inbreedingCoefficientEstimates': File,
            'otherFamilyHistory': OtherFamilyHistory,
            'pedigree': Pedigree,
            'pedigreeDiagram': File,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'BAMs': File,
            'VCFs': File,
            'annotationFile': File,
            'gVCFs': File,
            'inbreedingCoefficientEstimates': File,
            'otherFamilyHistory': OtherFamilyHistory,
            'pedigree': Pedigree,
            'pedigreeDiagram': File,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'BAMs', 'InterpretationRequestID',
        'InterpretationRequestVersion', 'VCFs', 'additionalInfo',
        'analysisReturnURI', 'analysisVersion', 'annotationFile',
        'bigWigs', 'complexGeneticPhenomena', 'gVCFs',
        'genomeAssemblyVersion', 'inbreedingCoefficientEstimates',
        'interpretGenome', 'modeOfInheritance', 'otherFamilyHistory',
        'pedigree', 'pedigreeDiagram', 'virtualPanel', 'workspace'
    ]

    def __init__(self, **kwargs):
        self.BAMs = kwargs.get(
            'BAMs', None)
        self.InterpretationRequestID = kwargs.get(
            'InterpretationRequestID', 'None')
        self.InterpretationRequestVersion = kwargs.get(
            'InterpretationRequestVersion', None)
        self.VCFs = kwargs.get(
            'VCFs', None)
        self.additionalInfo = kwargs.get(
            'additionalInfo', None)
        self.analysisReturnURI = kwargs.get(
            'analysisReturnURI', 'None')
        self.analysisVersion = kwargs.get(
            'analysisVersion', '1')
        self.annotationFile = kwargs.get(
            'annotationFile', None)
        self.bigWigs = kwargs.get(
            'bigWigs', None)
        self.complexGeneticPhenomena = kwargs.get(
            'complexGeneticPhenomena', None)
        self.gVCFs = kwargs.get(
            'gVCFs', None)
        self.genomeAssemblyVersion = kwargs.get(
            'genomeAssemblyVersion', 'GRCh37.p13')
        self.inbreedingCoefficientEstimates = kwargs.get(
            'inbreedingCoefficientEstimates', None)
        self.interpretGenome = kwargs.get(
            'interpretGenome', False)
        self.modeOfInheritance = kwargs.get(
            'modeOfInheritance', None)
        self.otherFamilyHistory = kwargs.get(
            'otherFamilyHistory', None)
        self.pedigree = kwargs.get(
            'pedigree', None)
        self.pedigreeDiagram = kwargs.get(
            'pedigreeDiagram', None)
        self.virtualPanel = kwargs.get(
            'virtualPanel', None)
        self.workspace = kwargs.get(
            'workspace', None)


class InterpretedGenomeRD(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"InterpretedGenomeRD", "fields": [{"doc": "", "type": "string",
"name": "InterpretationRequestID"}, {"doc": "", "type": "string",
"name": "analysisId"}, {"doc": "", "type": "string", "name":
"companyName"}, {"doc": "", "type": "string", "name": "reportURI"},
{"doc": "", "type": {"items": {"fields": [{"doc": "", "type":
"string", "name": "chromosome"}, {"doc": "", "type": ["null",
"string"], "name": "dbSNPid"}, {"doc": "", "type": "int", "name":
"position"}, {"doc": "", "type": "string", "name": "reference"},
{"doc": "", "type": "string", "name": "alternate"}, {"doc": "",
"type": {"items": {"doc": "", "type": "record", "name":
"CalledGenotype", "fields": [{"doc": "", "type": "string", "name":
"gelId"}, {"doc": "", "type": "string", "name": "genotype"}, {"doc":
"", "type": ["null", "int"], "name": "depthReference"}, {"doc": "",
"type": ["null", "int"], "name": "depthAlternate"}, {"doc": "",
"type": ["null", "int"], "name": "copyNumber"}]}, "type": "array"},
"name": "calledGenotypes"}, {"doc": "", "type": {"items": {"fields":
[{"doc": "", "type": "string", "name": "reportEventId"}, {"doc": "",
"type": "string", "name": "modeOfInheritance"}, {"doc": "", "type":
{"fields": [{"doc": "", "type": "string", "name": "geneSymbol"},
{"doc": "", "type": "string", "name": "transcriptId"}, {"doc": "",
"type": {"values": "string", "type": "map"}, "name": "ids"}, {"doc":
"", "type": ["null", "double"], "name": "geneCoverage"}], "type":
"record", "name": "Transcript"}, "name": "transcript"}, {"doc": "",
"type": {"symbols": ["complete", "incomplete"], "doc": "", "type":
"enum", "name": "Penetrance"}, "name": "penetrance"}, {"doc": "",
"type": "float", "name": "score"}, {"doc": "", "type": ["null",
{"values": "float", "type": "map"}], "name": "vendorSpecificScores"},
{"doc": "", "type": ["null", {"symbols": ["BENIGN", "LIKELY_BENIGN",
"VUS", "LIKELY_PATHOGENIC", "PATHOGENIC"], "doc": "", "type": "enum",
"name": "VariantClassification"}], "name": "variantClassification"},
{"doc": "", "type": ["null", "boolean"], "name":
"fullyExplainsPhenotype"}, {"doc": "", "type": ["null", "int"],
"name": "groupOfVariants"}, {"doc": "", "type": "string", "name":
"eventJustification"}, {"doc": "", "type": ["null", {"symbols":
["NONE", "TIER1", "TIER2", "TIER3"], "doc": "", "type": "enum",
"name": "Tier"}], "name": "tier"}], "type": "record", "name":
"ReportEvent"}, "type": "array"}, "name": "reportEvents"}, {"doc": "",
"type": ["null", {"values": "string", "type": "map"}], "name":
"additionalTextualVariantAnnotations"}, {"doc": "", "type": ["null",
{"values": "float", "type": "map"}], "name":
"additionalNumericVariantAnnotations"}, {"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "comments"}], "type":
"record", "name": "ReportedVariant"}, "type": "array"}, "name":
"reportedVariants"}, {"doc": "", "type": ["null", {"items": {"fields":
[{"doc": "", "type": "string", "name": "chromosome"}, {"doc": "",
"type": "int", "name": "start"}, {"doc": "", "type": "int", "name":
"end"}, {"doc": "", "type": "string", "name": "type"}, {"doc": "",
"type": "string", "name": "reference"}, {"doc": "", "type": "string",
"name": "alternate"}, {"type": {"items": "CalledGenotype", "type":
"array"}, "name": "calledGenotypes"}, {"doc": "", "type": {"items":
"ReportEvent", "type": "array"}, "name": "reportEvents"}, {"doc": "",
"type": ["null", {"values": "string", "type": "map"}], "name":
"additionalTextualVariantAnnotations"}, {"doc": "", "type": ["null",
{"values": "float", "type": "map"}], "name":
"additionalNumericVariantAnnotations"}, {"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "comments"}], "type":
"record", "name": "ReportedStructuralVariant"}, "type": "array"}],
"name": "reportedStructuralVariants"}, {"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "comments"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "InterpretationRequestID",
        "analysisId",
        "comments",
        "companyName",
        "reportURI",
        "reportedStructuralVariants",
        "reportedVariants",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'reportedVariants': ReportedVariant,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'reportedVariants': ReportedVariant,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'InterpretationRequestID', 'analysisId', 'comments',
        'companyName', 'reportURI', 'reportedStructuralVariants',
        'reportedVariants'
    ]

    def __init__(self, **kwargs):
        self.InterpretationRequestID = kwargs.get(
            'InterpretationRequestID', 'None')
        self.analysisId = kwargs.get(
            'analysisId', 'None')
        self.comments = kwargs.get(
            'comments', None)
        self.companyName = kwargs.get(
            'companyName', 'None')
        self.reportURI = kwargs.get(
            'reportURI', 'None')
        self.reportedStructuralVariants = kwargs.get(
            'reportedStructuralVariants', None)
        self.reportedVariants = kwargs.get(
            'reportedVariants', None)


class KGPopCategory(object):
    """
    1K Super Population
    """
    ACB = "ACB"
    ASW = "ASW"
    BEB = "BEB"
    CDX = "CDX"
    CEU = "CEU"
    CHB = "CHB"
    CHS = "CHS"
    CLM = "CLM"
    ESN = "ESN"
    FIN = "FIN"
    GBR = "GBR"
    GIH = "GIH"
    GWD = "GWD"
    IBS = "IBS"
    ITU = "ITU"
    JPT = "JPT"
    KHV = "KHV"
    LWK = "LWK"
    MSL = "MSL"
    MXL = "MXL"
    PEL = "PEL"
    PJL = "PJL"
    PUR = "PUR"
    STU = "STU"
    TSI = "TSI"
    YRI = "YRI"


class KGSuperPopCategory(object):
    """
    1K Population
    """
    AFR = "AFR"
    AMR = "AMR"
    EAS = "EAS"
    EUR = "EUR"
    SAS = "SAS"


class LifeStatus(object):
    """
    Life Status
    """
    alive = "alive"
    aborted = "aborted"
    deceased = "deceased"
    unborn = "unborn"
    stillborn = "stillborn"
    miscarriage = "miscarriage"


class MatchedSamples(ProtocolElement):
    """
    This define a pair of germline and tumor, this pair should/must be
    analyzed together
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"MatchedSamples", "fields": [{"doc": "", "type": "string", "name":
"germlineSampleId"}, {"doc": "", "type": "string", "name":
"tumorSampleId"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "germlineSampleId",
        "tumorSampleId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'germlineSampleId', 'tumorSampleId'
    ]

    def __init__(self, **kwargs):
        self.germlineSampleId = kwargs.get(
            'germlineSampleId', 'None')
        self.tumorSampleId = kwargs.get(
            'tumorSampleId', 'None')


class Method(object):
    """
    No documentation
    """
    resection = "resection"
    biopsy = "biopsy"


class MethodsVersion(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"MethodsVersion", "fields": [{"doc": "", "type": "string", "name":
"methodsVersion"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "methodsVersion",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'methodsVersion'
    ]

    def __init__(self, **kwargs):
        self.methodsVersion = kwargs.get(
            'methodsVersion', 'None')


class ModeOfInheritance(object):
    """
    An enumeration for the different mode of inheritances:  *
    `monoallelic_not_imprinted`: MONOALLELIC, autosomal or
    pseudoautosomal, not imprinted *
    `monoallelic_maternally_imprinted`: MONOALLELIC, autosomal or
    pseudoautosomal, maternally imprinted (paternal allele expressed)
    * `monoallelic_paternally_imprinted`: MONOALLELIC, autosomal or
    pseudoautosomal, paternally imprinted (maternal allele expressed)
    * `monoallelic`: MONOALLELIC, autosomal or pseudoautosomal,
    imprinted status unknown * `biallelic`: BIALLELIC, autosomal or
    pseudoautosomal * `monoallelic_and_biallelic`: BOTH monoallelic
    and biallelic, autosomal or pseudoautosomal *
    `monoallelic_and_more_severe_biallelic`: BOTH monoallelic and
    biallelic, autosomal or pseudoautosomal (but BIALLELIC mutations
    cause a more SEVERE disease form), autosomal or pseudoautosomal *
    `xlinked_biallelic`: X-LINKED: hemizygous mutation in males,
    biallelic mutations in females * `xlinked_monoallelic`: X linked:
    hemizygous mutation in males, monoallelic mutations in females may
    cause disease (may be less severe, later onset than males) *
    `mitochondrial`: MITOCHONDRIAL * `unknown`: Unknown
    """
    monoallelic = "monoallelic"
    monoallelic_not_imprinted = "monoallelic_not_imprinted"
    monoallelic_maternally_imprinted = "monoallelic_maternally_imprinted"
    monoallelic_paternally_imprinted = "monoallelic_paternally_imprinted"
    biallelic = "biallelic"
    monoallelic_and_biallelic = "monoallelic_and_biallelic"
    monoallelic_and_more_severe_biallelic = "monoallelic_and_more_severe_biallelic"
    xlinked_biallelic = "xlinked_biallelic"
    xlinked_monoallelic = "xlinked_monoallelic"
    mitochondrial = "mitochondrial"
    unknown = "unknown"


class OtherFamilyHistory(ProtocolElement):
    """
    Family history for secondary findings Arrays of strings describing
    discrete family history phenotypes
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"OtherFamilyHistory", "fields": [{"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name":
"maternalFamilyHistory"}, {"doc": "", "type": ["null", {"items":
"string", "type": "array"}], "name": "paternalFamilyHistory"}], "doc":
""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "maternalFamilyHistory",
        "paternalFamilyHistory",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'maternalFamilyHistory', 'paternalFamilyHistory'
    ]

    def __init__(self, **kwargs):
        self.maternalFamilyHistory = kwargs.get(
            'maternalFamilyHistory', None)
        self.paternalFamilyHistory = kwargs.get(
            'paternalFamilyHistory', None)


class ParticipantInformation(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"ParticipantInformation", "fields": [{"doc": "", "type": "string",
"name": "participantName"}, {"doc": "", "type": "string", "name":
"participantDOB"}, {"doc": "", "type": "string", "name": "NHSNumber"},
{"doc": "", "type": ["null", "string"], "name": "hospitalNumber"},
{"doc": "", "type": "string", "name": "gender"}, {"doc": "", "type":
["null", "string"], "name": "affectionStatus"}, {"doc": "", "type":
["null", "string"], "name": "relationshipToProband"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "NHSNumber",
        "affectionStatus",
        "gender",
        "hospitalNumber",
        "participantDOB",
        "participantName",
        "relationshipToProband",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'NHSNumber', 'affectionStatus', 'gender', 'hospitalNumber',
        'participantDOB', 'participantName', 'relationshipToProband'
    ]

    def __init__(self, **kwargs):
        self.NHSNumber = kwargs.get(
            'NHSNumber', 'None')
        self.affectionStatus = kwargs.get(
            'affectionStatus', None)
        self.gender = kwargs.get(
            'gender', 'None')
        self.hospitalNumber = kwargs.get(
            'hospitalNumber', None)
        self.participantDOB = kwargs.get(
            'participantDOB', 'None')
        self.participantName = kwargs.get(
            'participantName', 'None')
        self.relationshipToProband = kwargs.get(
            'relationshipToProband', None)


class Pedigree(ProtocolElement):
    """
    This is the concept of a family with associated phenotypes as
    present in the record RDParticipant
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"Pedigree", "fields": [{"doc": "", "type": "string", "name":
"gelFamilyId"}, {"type": {"items": {"doc": "", "type": "record",
"name": "RDParticipant", "fields": [{"doc": "", "type": "int", "name":
"pedigreeId"}, {"doc": "", "type": "boolean", "name": "isProband"},
{"doc": "", "type": ["null", "string"], "name": "gelId"}, {"doc": "",
"type": "string", "name": "gelFamilyId"}, {"doc": "", "type":
{"symbols": ["male", "female", "undetermined"], "doc": "", "type":
"enum", "name": "Sex"}, "name": "sex"}, {"doc": "", "type": ["null",
"int"], "name": "fatherId"}, {"doc": "", "type": ["null", "int"],
"name": "motherId"}, {"doc": "", "type": ["null", "int"], "name":
"twinGroup"}, {"doc": "", "type": ["null", {"symbols": ["yes", "no",
"unknown"], "doc": "", "type": "enum", "name": "TernaryOption"}],
"name": "monozygotic"}, {"doc": "", "type": {"symbols":
["not_adopted", "adoptedin", "adoptedout"], "doc": "", "type": "enum",
"name": "AdoptedStatus"}, "name": "adoptedStatus"}, {"doc": "",
"type": {"symbols": ["alive", "aborted", "deceased", "unborn",
"stillborn", "miscarriage"], "doc": "", "type": "enum", "name":
"LifeStatus"}, "name": "lifeStatus"}, {"doc": "", "type":
"TernaryOption", "name": "consanguineousParents"}, {"doc": "", "type":
["null", "string"], "name": "consanguineousPopulation"}, {"doc": "",
"type": {"symbols": ["unaffected", "affected", "unknown"], "doc": "",
"type": "enum", "name": "AffectionStatus"}, "name":
"affectionStatus"}, {"doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Disorder", "fields": [{"doc": "", "type": ["null",
"string"], "name": "diseaseGroup"}, {"doc": "", "type": ["null",
"string"], "name": "diseaseSubGroup"}, {"doc": "", "type": ["null",
"string"], "name": "specificDisease"}, {"doc": "", "type": ["null",
"int"], "name": "ageOfOnset"}]}, "type": "array"}, "name":
"disorderList"}, {"doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "HpoTerm", "fields": [{"doc": "", "type": "string",
"name": "term"}, {"doc": "", "type": "boolean", "name":
"termPresence"}, {"doc": "", "type": ["null", {"values": "string",
"type": "map"}], "name": "modifiers"}, {"doc": "", "type": ["null",
"int"], "name": "ageOfOnset"}]}, "type": "array"}, "name":
"hpoTermList"}, {"doc": "", "type": {"fields": [{"doc": "", "type":
["null", {"symbols": ["D", "E", "F", "G", "A", "B", "C", "L", "M",
"N", "H", "J", "K", "P", "S", "R", "Z"], "doc": "", "type": "enum",
"name": "EthnicCategory"}], "name": "mothersEthnicOrigin"}, {"doc":
"", "type": ["null", "string"], "name":
"mothersOtherRelevantAncestry"}, {"doc": "", "type": ["null",
"EthnicCategory"], "name": "fathersEthnicOrigin"}, {"doc": "", "type":
["null", "string"], "name": "fathersOtherRelevantAncestry"}, {"doc":
"", "type": ["null", {"items": {"doc": "", "type": "record", "name":
"ChiSquare1KGenomesPhase3Pop", "fields": [{"doc": "", "type":
{"symbols": ["AFR", "AMR", "EAS", "EUR", "SAS"], "doc": "", "type":
"enum", "name": "KGSuperPopCategory"}, "name": "kGSuperPopCategory"},
{"doc": "", "type": ["null", {"symbols": ["ACB", "ASW", "BEB", "CDX",
"CEU", "CHB", "CHS", "CLM", "ESN", "FIN", "GBR", "GIH", "GWD", "IBS",
"ITU", "JPT", "KHV", "LWK", "MSL", "MXL", "PEL", "PJL", "PUR", "STU",
"TSI", "YRI"], "doc": "", "type": "enum", "name": "KGPopCategory"}],
"name": "kGPopCategory"}, {"doc": "", "type": "float", "name":
"chiSquare"}]}, "type": "array"}], "name":
"chiSquare1KGenomesPhase3Pop"}], "type": "record", "name":
"Ancestries"}, "name": "ancestries"}, {"default": "v4.2", "doc": "",
"type": "string", "name": "dataModelCatalogueVersion"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "ConsentStatus",
"fields": [{"default": false, "doc": "", "type": "boolean", "name":
"programmeConsent"}, {"default": false, "doc": "", "type": "boolean",
"name": "primaryFindingConsent"}, {"default": false, "doc": "",
"type": "boolean", "name": "secondaryFindingConsent"}, {"default":
false, "doc": "", "type": "boolean", "name":
"carrierStatusConsent"}]}, "name": "consentStatus"}, {"doc": "",
"type": ["null", {"items": "string", "type": "array"}], "name":
"samples"}, {"doc": "", "type": ["null", {"values": "string", "type":
"map"}], "name": "additionalInformation"}]}, "type": "array"}, "name":
"participants"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "gelFamilyId",
        "participants",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'participants': RDParticipant,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'participants': RDParticipant,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'gelFamilyId', 'participants'
    ]

    def __init__(self, **kwargs):
        self.gelFamilyId = kwargs.get(
            'gelFamilyId', 'None')
        self.participants = kwargs.get(
            'participants', None)


class PedigreeMember(ProtocolElement):
    """
    This defines a pedigree member
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"PedigreeMember", "fields": [{"doc": "", "type": "int", "name":
"pedigreeId"}, {"doc": "", "type": ["null", "string"], "name":
"gelId"}, {"doc": "", "type": ["null", "string"], "name":
"firstName"}, {"doc": "", "type": ["null", "string"], "name":
"surname"}, {"doc": "", "type": ["null", "string"], "name":
"NHSNumber"}, {"doc": "", "type": ["null", "string"], "name":
"dateBirth"}, {"doc": "", "type": ["null", {"items": "string", "type":
"array"}], "name": "externalIds"}, {"type": {"symbols": ["male",
"female", "undetermined"], "doc": "", "type": "enum", "name": "Sex"},
"name": "sex"}, {"doc": "", "type": ["null", "int"], "name":
"fatherId"}, {"doc": "", "type": ["null", "int"], "name": "motherId"},
{"doc": "", "type": ["null", "int"], "name": "twinGroup"}, {"doc": "",
"type": ["null", {"symbols": ["yes", "no", "unknown"], "doc": "",
"type": "enum", "name": "TernaryOption"}], "name": "monozygotic"},
{"doc": "", "type": {"symbols": ["not_adopted", "adoptedin",
"adoptedout"], "doc": "", "type": "enum", "name": "AdoptedStatus"},
"name": "adoptedStatus"}, {"doc": "", "type": {"symbols": ["alive",
"aborted", "deceased", "unborn", "stillborn", "miscarriage"], "doc":
"", "type": "enum", "name": "LifeStatus"}, "name": "lifeStatus"},
{"doc": "", "type": "TernaryOption", "name": "consanguineousParents"},
{"doc": "", "type": {"symbols": ["unaffected", "affected", "unknown"],
"doc": "", "type": "enum", "name": "AffectionStatus"}, "name":
"affectionStatus"}, {"doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Disorder", "fields": [{"doc": "", "type": ["null",
"string"], "name": "diseaseGroup"}, {"doc": "", "type": ["null",
"string"], "name": "diseaseSubGroup"}, {"doc": "", "type": ["null",
"string"], "name": "specificDisease"}, {"doc": "", "type": ["null",
"int"], "name": "ageOfOnset"}]}, "type": "array"}, "name":
"disorderList"}, {"doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "HpoTerm", "fields": [{"doc": "", "type": "string",
"name": "term"}, {"doc": "", "type": "boolean", "name":
"termPresent"}, {"doc": "", "type": ["null", {"items": "string",
"type": "array"}], "name": "modifiers"}, {"doc": "", "type": ["null",
"int"], "name": "ageOfOnset"}]}, "type": "array"}, "name":
"hpoTermList"}, {"default": "v4.2", "doc": "", "type": "string",
"name": "dataModelCatalogueVersion"}, {"doc": "", "type": ["null",
{"values": "string", "type": "map"}], "name":
"additionalInformation"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "NHSNumber",
        "additionalInformation",
        "adoptedStatus",
        "affectionStatus",
        "consanguineousParents",
        "dateBirth",
        "disorderList",
        "externalIds",
        "fatherId",
        "firstName",
        "gelId",
        "hpoTermList",
        "lifeStatus",
        "monozygotic",
        "motherId",
        "pedigreeId",
        "sex",
        "surname",
        "twinGroup",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'disorderList': Disorder,
            'hpoTermList': HpoTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'disorderList': Disorder,
            'hpoTermList': HpoTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'NHSNumber', 'additionalInformation', 'adoptedStatus',
        'affectionStatus', 'consanguineousParents',
        'dataModelCatalogueVersion', 'dateBirth', 'disorderList',
        'externalIds', 'fatherId', 'firstName', 'gelId',
        'hpoTermList', 'lifeStatus', 'monozygotic', 'motherId',
        'pedigreeId', 'sex', 'surname', 'twinGroup'
    ]

    def __init__(self, **kwargs):
        self.NHSNumber = kwargs.get(
            'NHSNumber', None)
        self.additionalInformation = kwargs.get(
            'additionalInformation', None)
        self.adoptedStatus = kwargs.get(
            'adoptedStatus', None)
        self.affectionStatus = kwargs.get(
            'affectionStatus', None)
        self.consanguineousParents = kwargs.get(
            'consanguineousParents', None)
        self.dataModelCatalogueVersion = kwargs.get(
            'dataModelCatalogueVersion', 'v4.2')
        self.dateBirth = kwargs.get(
            'dateBirth', None)
        self.disorderList = kwargs.get(
            'disorderList', None)
        self.externalIds = kwargs.get(
            'externalIds', None)
        self.fatherId = kwargs.get(
            'fatherId', None)
        self.firstName = kwargs.get(
            'firstName', None)
        self.gelId = kwargs.get(
            'gelId', None)
        self.hpoTermList = kwargs.get(
            'hpoTermList', None)
        self.lifeStatus = kwargs.get(
            'lifeStatus', None)
        self.monozygotic = kwargs.get(
            'monozygotic', None)
        self.motherId = kwargs.get(
            'motherId', None)
        self.pedigreeId = kwargs.get(
            'pedigreeId', None)
        self.sex = kwargs.get(
            'sex', None)
        self.surname = kwargs.get(
            'surname', None)
        self.twinGroup = kwargs.get(
            'twinGroup', None)


class Penetrance(object):
    """
    Penetrance assumed in the analysis
    """
    complete = "complete"
    incomplete = "incomplete"


class Phase(object):
    """
    No documentation
    """
    primary = "primary"
    metastasis = "metastasis"


class PreservationMethod(object):
    """
    No documentation
    """
    FFPE = "FFPE"
    FF = "FF"
    Unknown = "Unknown"
    LEUK = "LEUK"
    GL = "GL"


class Provenance(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"Provenance", "fields": [{"doc": "", "type": {"items": {"doc": "",
"type": "record", "name": "File", "fields": [{"doc": "", "type":
["null", "string", {"items": "string", "type": "array"}], "name":
"SampleId"}, {"doc": "", "type": "string", "name": "URIFile"}]},
"type": "array"}, "name": "sampleProvenance"}, {"doc": "", "type":
{"items": "File", "type": "array"}, "name": "concordanceChecks"},
{"doc": "", "type": ["null", {"items": "File", "type": "array"}],
"name": "pathogenDetection"}, {"doc": "", "type": ["null", {"items":
"File", "type": "array"}], "name": "crossSpeciesContamination"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "concordanceChecks",
        "crossSpeciesContamination",
        "pathogenDetection",
        "sampleProvenance",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'concordanceChecks': File,
            'sampleProvenance': File,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'concordanceChecks': File,
            'sampleProvenance': File,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'concordanceChecks', 'crossSpeciesContamination',
        'pathogenDetection', 'sampleProvenance'
    ]

    def __init__(self, **kwargs):
        self.concordanceChecks = kwargs.get(
            'concordanceChecks', None)
        self.crossSpeciesContamination = kwargs.get(
            'crossSpeciesContamination', None)
        self.pathogenDetection = kwargs.get(
            'pathogenDetection', None)
        self.sampleProvenance = kwargs.get(
            'sampleProvenance', None)


class QualityControl(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"QualityControl", "fields": [{"doc": "", "type": ["null", {"items":
{"doc": "", "type": "record", "name": "File", "fields": [{"doc": "",
"type": ["null", "string", {"items": "string", "type": "array"}],
"name": "SampleId"}, {"doc": "", "type": "string", "name":
"URIFile"}]}, "type": "array"}], "name": "LOH"}, {"doc": "", "type":
["null", {"items": "File", "type": "array"}], "name": "ROH"}, {"doc":
"", "type": ["null", {"items": "File", "type": "array"}], "name":
"UPD"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "LOH",
        "ROH",
        "UPD",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'LOH', 'ROH', 'UPD'
    ]

    def __init__(self, **kwargs):
        self.LOH = kwargs.get(
            'LOH', None)
        self.ROH = kwargs.get(
            'ROH', None)
        self.UPD = kwargs.get(
            'UPD', None)


class RDCaseLog(ProtocolElement):
    """
    Rare Disease Case Log
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"RDCaseLog", "fields": [{"doc": "", "type": ["null", {"doc": "",
"type": "record", "name": "CommonQualityControl", "fields": [{"doc":
"", "type": ["null", {"items": {"doc": "", "type": "record", "name":
"File", "fields": [{"doc": "", "type": ["null", "string", {"items":
"string", "type": "array"}], "name": "SampleId"}, {"doc": "", "type":
"string", "name": "URIFile"}]}, "type": "array"}], "name":
"mendelErrors"}, {"doc": "", "type": ["null", {"items": "File",
"type": "array"}], "name": "sexPrediction"}, {"doc": "", "type":
["null", {"items": "File", "type": "array"}], "name":
"relatednessCheck"}, {"doc": "", "type": ["null", {"items": "File",
"type": "array"}], "name": "humanContminationFraction"}]}], "name":
"commonQualityControl"}, {"doc": "", "type": ["null", {"doc": "",
"type": "record", "name": "RDQualityControl", "fields": [{"doc": "",
"type": ["null", {"items": "File", "type": "array"}], "name":
"IBDSharing"}, {"doc": "", "type": ["null", {"items": "File", "type":
"array"}], "name": "inbreedingCoefficients"}]}], "name":
"rDQualityControl"}, {"doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "VariantFilters", "fields": [{"doc": "", "type":
["null", "double"], "name": "totalVariants"}, {"doc": "", "type":
["null", "double"], "name": "totalRareVariants"}, {"doc": "", "type":
["null", "double"], "name": "rareFunctionalVariants"}]}], "name":
"variantFilters"}, {"doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "VariantMOI", "fields": [{"doc": "", "type":
["null", "double"], "name": "totalHeterozygousDominant"}, {"doc": "",
"type": ["null", "double"], "name": "totalHomozygousRecessive"},
{"doc": "", "type": ["null", "double"], "name":
"totalCompoundHeterozygusRecessive"}, {"doc": "", "type": ["null",
"double"], "name": "totalXLinkedRecessive"}, {"doc": "", "type":
["null", "double"], "name": "totalXLinkedDominant"}, {"doc": "",
"type": ["null", "double"], "name": "deNovo"}]}], "name":
"variantMOI"}, {"doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "TieredVariants", "fields": [{"doc": "", "type":
["null", "double"], "name": "totalNoTier1"}, {"doc": "", "type":
["null", "double"], "name": "totalNoTier2"}, {"doc": "", "type":
["null", "double"], "name": "totalNoTier3"}]}], "name":
"tieredVariants"}, {"doc": "", "type": ["null", {"doc": "", "type":
"record", "name": "InterpretationAuthorisation", "fields": [{"doc":
"", "type": ["null", "string"], "name":
"interpretationAuthorisationDate"}, {"doc": "", "type": ["null",
"string"], "name": "nameOfAuthoriser"}, {"doc": "", "type": ["null",
{"items": {"doc": "", "type": "record", "name": "ReportEvents",
"fields": [{"doc": "", "type": ["null", "string"], "name":
"reportEventId"}, {"doc": "", "type": ["null", {"symbols":
["approved", "rejected"], "type": "enum", "name":
"ReportEventStatus"}], "name": "reportEventStatus"}, {"doc": "",
"type": ["null", "string"], "name": "authorisationJustification"}]},
"type": "array"}], "name": "reportEvents"}]}], "name":
"interpretationAuthorisation"}, {"doc": "", "type": "string", "name":
"gelInterimID"}, {"doc": "", "type": {"fields": [{"doc": "", "type":
"string", "name": "reportID"}, {"doc": "", "type": "float", "name":
"reportDate"}], "type": "record", "name": "Tracking"}, "name":
"tracking"}, {"doc": "", "type": {"doc": "", "type": "record", "name":
"ConsentStatus", "fields": [{"default": false, "doc": "", "type":
"boolean", "name": "programmeConsent"}, {"default": false, "doc": "",
"type": "boolean", "name": "primaryFindingConsent"}, {"default":
false, "doc": "", "type": "boolean", "name":
"secondaryFindingConsent"}, {"default": false, "doc": "", "type":
"boolean", "name": "carrierStatusConsent"}]}, "name":
"consentStatus"}, {"doc": "", "type": ["null", {"fields": [{"doc": "",
"type": "string", "name": "genePanelName"}, {"doc": "", "type":
"string", "name": "genePanelVersion"}], "type": "record", "name":
"GenePanels"}], "name": "genePanels"}, {"doc": "", "type": ["null",
{"fields": [{"doc": "", "type": {"items": "File", "type": "array"},
"name": "genomeWideCoverage15x"}, {"doc": "", "type": {"items":
"File", "type": "array"}, "name": "genomeWideCoverage30"}, {"doc": "",
"type": ["null", {"items": "File", "type": "array"}], "name":
"genePanelCoveragePanel"}, {"doc": "", "type": ["null", {"items":
"File", "type": "array"}], "name": "genePanelCoverageGenes"}], "type":
"record", "name": "CoverageMetrics"}], "name": "coverageMetrics"},
{"doc": "", "type": ["null", {"fields": [{"doc": "", "type": {"items":
"File", "type": "array"}, "name": "sampleProvenance"}, {"doc": "",
"type": {"items": "File", "type": "array"}, "name":
"concordanceChecks"}, {"doc": "", "type": ["null", {"items": "File",
"type": "array"}], "name": "pathogenDetection"}, {"doc": "", "type":
["null", {"items": "File", "type": "array"}], "name":
"crossSpeciesContamination"}], "type": "record", "name":
"Provenance"}], "name": "provenance"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "commonQualityControl",
        "consentStatus",
        "coverageMetrics",
        "gelInterimID",
        "genePanels",
        "interpretationAuthorisation",
        "provenance",
        "rDQualityControl",
        "tieredVariants",
        "tracking",
        "variantFilters",
        "variantMOI",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'commonQualityControl': CommonQualityControl,
            'consentStatus': ConsentStatus,
            'coverageMetrics': CoverageMetrics,
            'genePanels': GenePanels,
            'interpretationAuthorisation': InterpretationAuthorisation,
            'provenance': Provenance,
            'rDQualityControl': RDQualityControl,
            'tieredVariants': TieredVariants,
            'tracking': Tracking,
            'variantFilters': VariantFilters,
            'variantMOI': VariantMOI,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'commonQualityControl': CommonQualityControl,
            'consentStatus': ConsentStatus,
            'coverageMetrics': CoverageMetrics,
            'genePanels': GenePanels,
            'interpretationAuthorisation': InterpretationAuthorisation,
            'provenance': Provenance,
            'rDQualityControl': RDQualityControl,
            'tieredVariants': TieredVariants,
            'tracking': Tracking,
            'variantFilters': VariantFilters,
            'variantMOI': VariantMOI,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'commonQualityControl', 'consentStatus', 'coverageMetrics',
        'gelInterimID', 'genePanels', 'interpretationAuthorisation',
        'provenance', 'rDQualityControl', 'tieredVariants',
        'tracking', 'variantFilters', 'variantMOI'
    ]

    def __init__(self, **kwargs):
        self.commonQualityControl = kwargs.get(
            'commonQualityControl', None)
        self.consentStatus = kwargs.get(
            'consentStatus', None)
        self.coverageMetrics = kwargs.get(
            'coverageMetrics', None)
        self.gelInterimID = kwargs.get(
            'gelInterimID', 'None')
        self.genePanels = kwargs.get(
            'genePanels', None)
        self.interpretationAuthorisation = kwargs.get(
            'interpretationAuthorisation', None)
        self.provenance = kwargs.get(
            'provenance', None)
        self.rDQualityControl = kwargs.get(
            'rDQualityControl', None)
        self.tieredVariants = kwargs.get(
            'tieredVariants', None)
        self.tracking = kwargs.get(
            'tracking', None)
        self.variantFilters = kwargs.get(
            'variantFilters', None)
        self.variantMOI = kwargs.get(
            'variantMOI', None)


class RDDisclaimers(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"RDDisclaimers", "fields": [{"doc": "", "type": "string", "name":
"RDResearchDisclaimer"}, {"doc": "", "type": "string", "name":
"reportContext"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "RDResearchDisclaimer",
        "reportContext",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'RDResearchDisclaimer', 'reportContext'
    ]

    def __init__(self, **kwargs):
        self.RDResearchDisclaimer = kwargs.get(
            'RDResearchDisclaimer', 'None')
        self.reportContext = kwargs.get(
            'reportContext', 'None')


class RDParticipant(ProtocolElement):
    """
    This defines a RD Participant (demographics and pedigree
    information)
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"RDParticipant", "fields": [{"doc": "", "type": "int", "name":
"pedigreeId"}, {"doc": "", "type": "boolean", "name": "isProband"},
{"doc": "", "type": ["null", "string"], "name": "gelId"}, {"doc": "",
"type": "string", "name": "gelFamilyId"}, {"doc": "", "type":
{"symbols": ["male", "female", "undetermined"], "doc": "", "type":
"enum", "name": "Sex"}, "name": "sex"}, {"doc": "", "type": ["null",
"int"], "name": "fatherId"}, {"doc": "", "type": ["null", "int"],
"name": "motherId"}, {"doc": "", "type": ["null", "int"], "name":
"twinGroup"}, {"doc": "", "type": ["null", {"symbols": ["yes", "no",
"unknown"], "doc": "", "type": "enum", "name": "TernaryOption"}],
"name": "monozygotic"}, {"doc": "", "type": {"symbols":
["not_adopted", "adoptedin", "adoptedout"], "doc": "", "type": "enum",
"name": "AdoptedStatus"}, "name": "adoptedStatus"}, {"doc": "",
"type": {"symbols": ["alive", "aborted", "deceased", "unborn",
"stillborn", "miscarriage"], "doc": "", "type": "enum", "name":
"LifeStatus"}, "name": "lifeStatus"}, {"doc": "", "type":
"TernaryOption", "name": "consanguineousParents"}, {"doc": "", "type":
["null", "string"], "name": "consanguineousPopulation"}, {"doc": "",
"type": {"symbols": ["unaffected", "affected", "unknown"], "doc": "",
"type": "enum", "name": "AffectionStatus"}, "name":
"affectionStatus"}, {"doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "Disorder", "fields": [{"doc": "", "type": ["null",
"string"], "name": "diseaseGroup"}, {"doc": "", "type": ["null",
"string"], "name": "diseaseSubGroup"}, {"doc": "", "type": ["null",
"string"], "name": "specificDisease"}, {"doc": "", "type": ["null",
"int"], "name": "ageOfOnset"}]}, "type": "array"}, "name":
"disorderList"}, {"doc": "", "type": {"items": {"doc": "", "type":
"record", "name": "HpoTerm", "fields": [{"doc": "", "type": "string",
"name": "term"}, {"doc": "", "type": "boolean", "name":
"termPresence"}, {"doc": "", "type": ["null", {"values": "string",
"type": "map"}], "name": "modifiers"}, {"doc": "", "type": ["null",
"int"], "name": "ageOfOnset"}]}, "type": "array"}, "name":
"hpoTermList"}, {"doc": "", "type": {"fields": [{"doc": "", "type":
["null", {"symbols": ["D", "E", "F", "G", "A", "B", "C", "L", "M",
"N", "H", "J", "K", "P", "S", "R", "Z"], "doc": "", "type": "enum",
"name": "EthnicCategory"}], "name": "mothersEthnicOrigin"}, {"doc":
"", "type": ["null", "string"], "name":
"mothersOtherRelevantAncestry"}, {"doc": "", "type": ["null",
"EthnicCategory"], "name": "fathersEthnicOrigin"}, {"doc": "", "type":
["null", "string"], "name": "fathersOtherRelevantAncestry"}, {"doc":
"", "type": ["null", {"items": {"doc": "", "type": "record", "name":
"ChiSquare1KGenomesPhase3Pop", "fields": [{"doc": "", "type":
{"symbols": ["AFR", "AMR", "EAS", "EUR", "SAS"], "doc": "", "type":
"enum", "name": "KGSuperPopCategory"}, "name": "kGSuperPopCategory"},
{"doc": "", "type": ["null", {"symbols": ["ACB", "ASW", "BEB", "CDX",
"CEU", "CHB", "CHS", "CLM", "ESN", "FIN", "GBR", "GIH", "GWD", "IBS",
"ITU", "JPT", "KHV", "LWK", "MSL", "MXL", "PEL", "PJL", "PUR", "STU",
"TSI", "YRI"], "doc": "", "type": "enum", "name": "KGPopCategory"}],
"name": "kGPopCategory"}, {"doc": "", "type": "float", "name":
"chiSquare"}]}, "type": "array"}], "name":
"chiSquare1KGenomesPhase3Pop"}], "type": "record", "name":
"Ancestries"}, "name": "ancestries"}, {"default": "v4.2", "doc": "",
"type": "string", "name": "dataModelCatalogueVersion"}, {"doc": "",
"type": {"doc": "", "type": "record", "name": "ConsentStatus",
"fields": [{"default": false, "doc": "", "type": "boolean", "name":
"programmeConsent"}, {"default": false, "doc": "", "type": "boolean",
"name": "primaryFindingConsent"}, {"default": false, "doc": "",
"type": "boolean", "name": "secondaryFindingConsent"}, {"default":
false, "doc": "", "type": "boolean", "name":
"carrierStatusConsent"}]}, "name": "consentStatus"}, {"doc": "",
"type": ["null", {"items": "string", "type": "array"}], "name":
"samples"}, {"doc": "", "type": ["null", {"values": "string", "type":
"map"}], "name": "additionalInformation"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "additionalInformation",
        "adoptedStatus",
        "affectionStatus",
        "ancestries",
        "consanguineousParents",
        "consanguineousPopulation",
        "consentStatus",
        "disorderList",
        "fatherId",
        "gelFamilyId",
        "gelId",
        "hpoTermList",
        "isProband",
        "lifeStatus",
        "monozygotic",
        "motherId",
        "pedigreeId",
        "samples",
        "sex",
        "twinGroup",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'ancestries': Ancestries,
            'consentStatus': ConsentStatus,
            'disorderList': Disorder,
            'hpoTermList': HpoTerm,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'ancestries': Ancestries,
            'consentStatus': ConsentStatus,
            'disorderList': Disorder,
            'hpoTermList': HpoTerm,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'additionalInformation', 'adoptedStatus', 'affectionStatus',
        'ancestries', 'consanguineousParents',
        'consanguineousPopulation', 'consentStatus',
        'dataModelCatalogueVersion', 'disorderList', 'fatherId',
        'gelFamilyId', 'gelId', 'hpoTermList', 'isProband',
        'lifeStatus', 'monozygotic', 'motherId', 'pedigreeId',
        'samples', 'sex', 'twinGroup'
    ]

    def __init__(self, **kwargs):
        self.additionalInformation = kwargs.get(
            'additionalInformation', None)
        self.adoptedStatus = kwargs.get(
            'adoptedStatus', None)
        self.affectionStatus = kwargs.get(
            'affectionStatus', None)
        self.ancestries = kwargs.get(
            'ancestries', None)
        self.consanguineousParents = kwargs.get(
            'consanguineousParents', None)
        self.consanguineousPopulation = kwargs.get(
            'consanguineousPopulation', None)
        self.consentStatus = kwargs.get(
            'consentStatus', None)
        self.dataModelCatalogueVersion = kwargs.get(
            'dataModelCatalogueVersion', 'v4.2')
        self.disorderList = kwargs.get(
            'disorderList', None)
        self.fatherId = kwargs.get(
            'fatherId', None)
        self.gelFamilyId = kwargs.get(
            'gelFamilyId', 'None')
        self.gelId = kwargs.get(
            'gelId', None)
        self.hpoTermList = kwargs.get(
            'hpoTermList', None)
        self.isProband = kwargs.get(
            'isProband', None)
        self.lifeStatus = kwargs.get(
            'lifeStatus', None)
        self.monozygotic = kwargs.get(
            'monozygotic', None)
        self.motherId = kwargs.get(
            'motherId', None)
        self.pedigreeId = kwargs.get(
            'pedigreeId', None)
        self.samples = kwargs.get(
            'samples', None)
        self.sex = kwargs.get(
            'sex', None)
        self.twinGroup = kwargs.get(
            'twinGroup', None)


class RDQualityControl(ProtocolElement):
    """
    Unique to rare disease case log
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"RDQualityControl", "fields": [{"doc": "", "type": ["null", {"items":
{"doc": "", "type": "record", "name": "File", "fields": [{"doc": "",
"type": ["null", "string", {"items": "string", "type": "array"}],
"name": "SampleId"}, {"doc": "", "type": "string", "name":
"URIFile"}]}, "type": "array"}], "name": "IBDSharing"}, {"doc": "",
"type": ["null", {"items": "File", "type": "array"}], "name":
"inbreedingCoefficients"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "IBDSharing",
        "inbreedingCoefficients",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'IBDSharing', 'inbreedingCoefficients'
    ]

    def __init__(self, **kwargs):
        self.IBDSharing = kwargs.get(
            'IBDSharing', None)
        self.inbreedingCoefficients = kwargs.get(
            'inbreedingCoefficients', None)


class RareDiseasePrimaryFindings(ProtocolElement):
    """
    Rare Disease Primary Findings
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"RareDiseasePrimaryFindings", "fields": [{"doc": "", "type":
{"fields": [{"doc": "", "type": ["null", {"values": "string", "type":
"map"}], "name": "analyst"}, {"doc": "", "type": ["null", {"values":
"string", "type": "map"}], "name": "clinicalGeneticist"}, {"doc": "",
"type": "string", "name": "genomicsEngland"}, {"doc": "", "type":
"string", "name": "contactMail"}], "type": "record", "name":
"Contact"}, "name": "contact"}, {"doc": "", "type": {"items":
{"fields": [{"doc": "", "type": ["null", "string"], "name":
"consultant"}, {"doc": "", "type": "string", "name": "GMC"}, {"doc":
"", "type": "string", "name": "GMCmail"}], "type": "record", "name":
"ClinicalResponsibility"}, "type": "array"}, "name":
"clinicalResponsibility"}, {"doc": "", "type": {"doc": "", "type":
"record", "name": "Sequencing", "fields": [{"doc": "", "type":
"string", "name": "SequencingCentre"}, {"doc": "", "type": "string",
"name": "SequencingAddress"}, {"doc": "", "type": ["null", "string"],
"name": "AccreditationStatus"}, {"doc": "", "type": ["null",
"string"], "name": "AccreditationDate"}]}, "name": "sequencing"},
{"doc": "", "type": "string", "name": "gELInterimId"}, {"doc": "",
"type": {"fields": [{"doc": "", "type": "string", "name": "reportID"},
{"doc": "", "type": "float", "name": "reportDate"}], "type": "record",
"name": "Tracking"}, "name": "tracking"}, {"doc": "", "type":
{"fields": [{"doc": "", "type": ["null", {"values": {"symbols":
["WuXiNextCODE", "Omicia", "Congenica"], "type": "enum", "name":
"Companies"}, "type": "map"}], "name": "interpretationCompany"},
{"doc": "", "type": ["null", {"values": "string", "type": "map"}],
"name": "interpretationRequestDate"}, {"doc": "", "type": ["null",
{"values": "string", "type": "map"}], "name":
"interpretationRequestID"}], "type": "record", "name":
"InterpretationRequest"}, "name": "interpretationRequest"}, {"doc":
"", "type": {"fields": [{"doc": "", "type": "string", "name":
"gelFamilyId"}, {"doc": "", "type": {"items": {"fields": [{"doc": "",
"type": "string", "name": "participantName"}, {"doc": "", "type":
"string", "name": "participantDOB"}, {"doc": "", "type": "string",
"name": "NHSNumber"}, {"doc": "", "type": ["null", "string"], "name":
"hospitalNumber"}, {"doc": "", "type": "string", "name": "gender"},
{"doc": "", "type": ["null", "string"], "name": "affectionStatus"},
{"doc": "", "type": ["null", "string"], "name":
"relationshipToProband"}], "type": "record", "name":
"ParticipantInformation"}, "type": "array"}, "name": "participants"},
{"doc": "", "type": ["null", "string"], "name": "pedigreeFile"}],
"type": "record", "name": "Pedigree"}, "name": "pedigree"}, {"doc":
"", "type": {"doc": "", "type": "record", "name": "ConsentStatus",
"fields": [{"default": false, "doc": "", "type": "boolean", "name":
"programmeConsent"}, {"default": false, "doc": "", "type": "boolean",
"name": "primaryFindingConsent"}, {"default": false, "doc": "",
"type": "boolean", "name": "secondaryFindingConsent"}, {"default":
false, "doc": "", "type": "boolean", "name":
"carrierStatusConsent"}]}, "name": "consentStatus"}, {"doc": "",
"type": {"fields": [{"doc": "", "type": "string", "name":
"methodsVersion"}], "type": "record", "name": "MethodsVersion"},
"name": "methodsVersion"}, {"doc": "", "type": ["null", {"fields":
[{"doc": "", "type": ["null", "string"], "name": "consanguinity"},
{"doc": "", "type": ["null", {"values": {"symbols": ["A", "B", "C",
"D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "S", "R", "Z"],
"type": "enum", "name": "EthnicOrigin"}, "type": "map"}], "name":
"mothersEthnicOrigin"}, {"doc": "", "type": ["null", {"values":
"EthnicOrigin", "type": "map"}], "name": "fathersEthnicOrigin"},
{"doc": "", "type": ["null", "string"], "name":
"mothersOtherRelevantAncestry"}, {"doc": "", "type": ["null",
"string"], "name": "fathersOtherRelevantAncestry"}, {"doc": "",
"type": ["null", "string", {"values": {"symbols":
["Colorectal_Cancer", "Breast_and_or_Ovarian_Cancer",
"Ischaemic_Heart_Disease_or_Stroke", "Endocrine_Tumours"], "type":
"enum", "name": "FamilyHistory"}, "type": "map"}], "name":
"maternalFamilyHistory"}, {"doc": "", "type": ["null", "string",
{"values": "FamilyHistory", "type": "map"}], "name":
"paternalFamilyHistory"}], "type": "record", "name":
"AdditionalInformation"}], "name": "additionalInformation"}, {"doc":
"", "type": {"fields": [{"doc": "", "type": "string", "name":
"RDResearchDisclaimer"}, {"doc": "", "type": "string", "name":
"reportContext"}], "type": "record", "name": "RDDisclaimers"}, "name":
"rDDisclaimers"}, {"doc": "", "type": {"items": {"fields": [{"doc":
"", "type": "string", "name": "recruitedDiseaseCategory"}], "type":
"record", "name": "RecruitedDiseaseCategory"}, "type": "array"},
"name": "recruitedDiseaseCategory1"}, {"doc": "", "type": ["null",
{"items": {"fields": [{"doc": "", "type": "string", "name":
"genePanelName"}, {"doc": "", "type": "string", "name":
"genePanelVersion"}], "type": "record", "name": "GenePanels"}, "type":
"array"}], "name": "genePanels"}, {"doc": "", "type": ["null",
{"items": {"doc": "", "type": "record", "name": "CandidateVariants",
"fields": [{"doc": "", "type": ["null", "int"], "name": "tier"},
{"doc": "", "type": "string", "name": "HGNCGeneSymbol"}, {"doc": "",
"type": "string", "name": "GRCh37coordinates"}, {"doc": "", "type":
["null", "int"], "name": "VariantSize"}, {"doc": "", "type": ["null",
"string"], "name": "transcriptID"}, {"doc": "", "type": ["null",
"string"], "name": "cDNAChange"}, {"doc": "", "type": ["null",
"string"], "name": "proteinChange"}, {"doc": "", "type": ["null",
"string"], "name": "predictedConsequence"}, {"doc": "", "type":
["null", "string"], "name": "rsID"}, {"doc": "", "type": "string",
"name": "depthAtPosition"}, {"doc": "", "type": ["null", "string"],
"name": "allelicFraction"}, {"doc": "", "type": "string", "name":
"genotype"}, {"doc": "", "type": ["null", "string"], "name":
"clinVarAccession"}, {"doc": "", "type": ["null", {"values": "double",
"type": "map"}], "name": "alleleFreq"}, {"doc": "", "type": "string",
"name": "modeOfInheritanceVariant"}, {"doc": "", "type": ["null",
"string"], "name": "modeOfInheritanceGene"}, {"doc": "", "type":
["null", "string"], "name": "knownPhenotype"}]}, "type": "array"}],
"name": "candidateVariants"}, {"doc": "", "type": ["null", {"fields":
[{"doc": "", "type": ["null", "string"], "name":
"interventionCategory"}, {"doc": "", "type": ["null", "string"],
"name": "clinicalTrials"}, {"doc": "", "type": ["null", "string"],
"name": "pharmacogenetic"}], "type": "record", "name":
"ActionableInformation"}], "name": "actionableInformation"}, {"doc":
"", "type": ["null", {"fields": [{"doc": "", "type": {"items": {"doc":
"", "type": "record", "name": "File", "fields": [{"doc": "", "type":
["null", "string", {"items": "string", "type": "array"}], "name":
"SampleId"}, {"doc": "", "type": "string", "name": "URIFile"}]},
"type": "array"}, "name": "sampleProvenance"}, {"doc": "", "type":
{"items": "File", "type": "array"}, "name": "concordanceChecks"},
{"doc": "", "type": ["null", {"items": "File", "type": "array"}],
"name": "pathogenDetection"}, {"doc": "", "type": ["null", {"items":
"File", "type": "array"}], "name": "crossSpeciesContamination"}],
"type": "record", "name": "Provenance"}], "name": "provenance"},
{"doc": "", "type": ["null", {"fields": [{"doc": "", "type": {"items":
"File", "type": "array"}, "name": "genomeWideCoverage15x"}, {"doc":
"", "type": {"items": "File", "type": "array"}, "name":
"genomeWideCoverage30"}, {"doc": "", "type": ["null", {"items":
"File", "type": "array"}], "name": "genePanelCoveragePanel"}, {"doc":
"", "type": ["null", {"items": "File", "type": "array"}], "name":
"genePanelCoverageGenes"}], "type": "record", "name":
"CoverageMetrics"}], "name": "coverageMetrics"}, {"doc": "", "type":
["null", {"fields": [{"doc": "", "type": ["null", {"items": "File",
"type": "array"}], "name": "LOH"}, {"doc": "", "type": ["null",
{"items": "File", "type": "array"}], "name": "ROH"}, {"doc": "",
"type": ["null", {"items": "File", "type": "array"}], "name": "UPD"}],
"type": "record", "name": "QualityControl"}], "name":
"qualityControl"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "actionableInformation",
        "additionalInformation",
        "candidateVariants",
        "clinicalResponsibility",
        "consentStatus",
        "contact",
        "coverageMetrics",
        "gELInterimId",
        "genePanels",
        "interpretationRequest",
        "methodsVersion",
        "pedigree",
        "provenance",
        "qualityControl",
        "rDDisclaimers",
        "recruitedDiseaseCategory1",
        "sequencing",
        "tracking",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'actionableInformation': ActionableInformation,
            'additionalInformation': AdditionalInformation,
            'clinicalResponsibility': ClinicalResponsibility,
            'consentStatus': ConsentStatus,
            'contact': Contact,
            'coverageMetrics': CoverageMetrics,
            'interpretationRequest': InterpretationRequest,
            'methodsVersion': MethodsVersion,
            'pedigree': Pedigree,
            'provenance': Provenance,
            'qualityControl': QualityControl,
            'rDDisclaimers': RDDisclaimers,
            'recruitedDiseaseCategory1': RecruitedDiseaseCategory,
            'sequencing': Sequencing,
            'tracking': Tracking,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'actionableInformation': ActionableInformation,
            'additionalInformation': AdditionalInformation,
            'clinicalResponsibility': ClinicalResponsibility,
            'consentStatus': ConsentStatus,
            'contact': Contact,
            'coverageMetrics': CoverageMetrics,
            'interpretationRequest': InterpretationRequest,
            'methodsVersion': MethodsVersion,
            'pedigree': Pedigree,
            'provenance': Provenance,
            'qualityControl': QualityControl,
            'rDDisclaimers': RDDisclaimers,
            'recruitedDiseaseCategory1': RecruitedDiseaseCategory,
            'sequencing': Sequencing,
            'tracking': Tracking,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'actionableInformation', 'additionalInformation',
        'candidateVariants', 'clinicalResponsibility',
        'consentStatus', 'contact', 'coverageMetrics', 'gELInterimId',
        'genePanels', 'interpretationRequest', 'methodsVersion',
        'pedigree', 'provenance', 'qualityControl', 'rDDisclaimers',
        'recruitedDiseaseCategory1', 'sequencing', 'tracking'
    ]

    def __init__(self, **kwargs):
        self.actionableInformation = kwargs.get(
            'actionableInformation', None)
        self.additionalInformation = kwargs.get(
            'additionalInformation', None)
        self.candidateVariants = kwargs.get(
            'candidateVariants', None)
        self.clinicalResponsibility = kwargs.get(
            'clinicalResponsibility', None)
        self.consentStatus = kwargs.get(
            'consentStatus', None)
        self.contact = kwargs.get(
            'contact', None)
        self.coverageMetrics = kwargs.get(
            'coverageMetrics', None)
        self.gELInterimId = kwargs.get(
            'gELInterimId', 'None')
        self.genePanels = kwargs.get(
            'genePanels', None)
        self.interpretationRequest = kwargs.get(
            'interpretationRequest', None)
        self.methodsVersion = kwargs.get(
            'methodsVersion', None)
        self.pedigree = kwargs.get(
            'pedigree', None)
        self.provenance = kwargs.get(
            'provenance', None)
        self.qualityControl = kwargs.get(
            'qualityControl', None)
        self.rDDisclaimers = kwargs.get(
            'rDDisclaimers', None)
        self.recruitedDiseaseCategory1 = kwargs.get(
            'recruitedDiseaseCategory1', None)
        self.sequencing = kwargs.get(
            'sequencing', None)
        self.tracking = kwargs.get(
            'tracking', None)


class RecruitedCancer(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"RecruitedCancer", "fields": [{"doc": "", "type": "string", "name":
"Cancer"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "Cancer",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'Cancer'
    ]

    def __init__(self, **kwargs):
        self.Cancer = kwargs.get(
            'Cancer', 'None')


class RecruitedDiseaseCategory(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"RecruitedDiseaseCategory", "fields": [{"doc": "", "type": "string",
"name": "recruitedDiseaseCategory"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "recruitedDiseaseCategory",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'recruitedDiseaseCategory'
    ]

    def __init__(self, **kwargs):
        self.recruitedDiseaseCategory = kwargs.get(
            'recruitedDiseaseCategory', 'None')


class ReportEvent(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"ReportEvent", "fields": [{"doc": "", "type": "string", "name":
"reportEventId"}, {"doc": "", "type": "string", "name":
"modeOfInheritance"}, {"doc": "", "type": {"fields": [{"doc": "",
"type": "string", "name": "geneSymbol"}, {"doc": "", "type": "string",
"name": "transcriptId"}, {"doc": "", "type": {"values": "string",
"type": "map"}, "name": "ids"}, {"doc": "", "type": ["null",
"double"], "name": "geneCoverage"}], "type": "record", "name":
"Transcript"}, "name": "transcript"}, {"doc": "", "type": {"symbols":
["complete", "incomplete"], "doc": "", "type": "enum", "name":
"Penetrance"}, "name": "penetrance"}, {"doc": "", "type": "float",
"name": "score"}, {"doc": "", "type": ["null", {"values": "float",
"type": "map"}], "name": "vendorSpecificScores"}, {"doc": "", "type":
["null", {"symbols": ["BENIGN", "LIKELY_BENIGN", "VUS",
"LIKELY_PATHOGENIC", "PATHOGENIC"], "doc": "", "type": "enum", "name":
"VariantClassification"}], "name": "variantClassification"}, {"doc":
"", "type": ["null", "boolean"], "name": "fullyExplainsPhenotype"},
{"doc": "", "type": ["null", "int"], "name": "groupOfVariants"},
{"doc": "", "type": "string", "name": "eventJustification"}, {"doc":
"", "type": ["null", {"symbols": ["NONE", "TIER1", "TIER2", "TIER3"],
"doc": "", "type": "enum", "name": "Tier"}], "name": "tier"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "eventJustification",
        "fullyExplainsPhenotype",
        "groupOfVariants",
        "modeOfInheritance",
        "penetrance",
        "reportEventId",
        "score",
        "tier",
        "transcript",
        "variantClassification",
        "vendorSpecificScores",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'transcript': Transcript,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'transcript': Transcript,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'eventJustification', 'fullyExplainsPhenotype',
        'groupOfVariants', 'modeOfInheritance', 'penetrance',
        'reportEventId', 'score', 'tier', 'transcript',
        'variantClassification', 'vendorSpecificScores'
    ]

    def __init__(self, **kwargs):
        self.eventJustification = kwargs.get(
            'eventJustification', 'None')
        self.fullyExplainsPhenotype = kwargs.get(
            'fullyExplainsPhenotype', None)
        self.groupOfVariants = kwargs.get(
            'groupOfVariants', None)
        self.modeOfInheritance = kwargs.get(
            'modeOfInheritance', 'None')
        self.penetrance = kwargs.get(
            'penetrance', None)
        self.reportEventId = kwargs.get(
            'reportEventId', 'None')
        self.score = kwargs.get(
            'score', None)
        self.tier = kwargs.get(
            'tier', None)
        self.transcript = kwargs.get(
            'transcript', None)
        self.variantClassification = kwargs.get(
            'variantClassification', None)
        self.vendorSpecificScores = kwargs.get(
            'vendorSpecificScores', None)


class ReportEventStatus(object):
    """
    No documentation
    """
    approved = "approved"
    rejected = "rejected"


class ReportEvents(ProtocolElement):
    """
    Unique to case log
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"ReportEvents", "fields": [{"doc": "", "type": ["null", "string"],
"name": "reportEventId"}, {"doc": "", "type": ["null", {"symbols":
["approved", "rejected"], "type": "enum", "name":
"ReportEventStatus"}], "name": "reportEventStatus"}, {"doc": "",
"type": ["null", "string"], "name": "authorisationJustification"}],
"doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "authorisationJustification",
        "reportEventId",
        "reportEventStatus",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'authorisationJustification', 'reportEventId',
        'reportEventStatus'
    ]

    def __init__(self, **kwargs):
        self.authorisationJustification = kwargs.get(
            'authorisationJustification', None)
        self.reportEventId = kwargs.get(
            'reportEventId', None)
        self.reportEventStatus = kwargs.get(
            'reportEventStatus', None)


class ReportedSomaticStructuralVariants(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"ReportedSomaticStructuralVariants", "fields": [{"doc": "", "type":
{"fields": [{"doc": "", "type": "string", "name": "chromosome"},
{"doc": "", "type": "int", "name": "start"}, {"doc": "", "type":
"int", "name": "end"}, {"doc": "", "type": "string", "name": "type"},
{"doc": "", "type": "string", "name": "reference"}, {"doc": "",
"type": "string", "name": "alternate"}, {"type": {"items": {"doc": "",
"type": "record", "name": "CalledGenotype", "fields": [{"doc": "",
"type": "string", "name": "gelId"}, {"doc": "", "type": "string",
"name": "genotype"}, {"doc": "", "type": ["null", "int"], "name":
"depthReference"}, {"doc": "", "type": ["null", "int"], "name":
"depthAlternate"}, {"doc": "", "type": ["null", "int"], "name":
"copyNumber"}]}, "type": "array"}, "name": "calledGenotypes"}, {"doc":
"", "type": {"items": {"fields": [{"doc": "", "type": "string",
"name": "reportEventId"}, {"doc": "", "type": "string", "name":
"modeOfInheritance"}, {"doc": "", "type": {"fields": [{"doc": "",
"type": "string", "name": "geneSymbol"}, {"doc": "", "type": "string",
"name": "transcriptId"}, {"doc": "", "type": {"values": "string",
"type": "map"}, "name": "ids"}, {"doc": "", "type": ["null",
"double"], "name": "geneCoverage"}], "type": "record", "name":
"Transcript"}, "name": "transcript"}, {"doc": "", "type": {"symbols":
["complete", "incomplete"], "doc": "", "type": "enum", "name":
"Penetrance"}, "name": "penetrance"}, {"doc": "", "type": "float",
"name": "score"}, {"doc": "", "type": ["null", {"values": "float",
"type": "map"}], "name": "vendorSpecificScores"}, {"doc": "", "type":
["null", {"symbols": ["BENIGN", "LIKELY_BENIGN", "VUS",
"LIKELY_PATHOGENIC", "PATHOGENIC"], "doc": "", "type": "enum", "name":
"VariantClassification"}], "name": "variantClassification"}, {"doc":
"", "type": ["null", "boolean"], "name": "fullyExplainsPhenotype"},
{"doc": "", "type": ["null", "int"], "name": "groupOfVariants"},
{"doc": "", "type": "string", "name": "eventJustification"}, {"doc":
"", "type": ["null", {"symbols": ["NONE", "TIER1", "TIER2", "TIER3"],
"doc": "", "type": "enum", "name": "Tier"}], "name": "tier"}], "type":
"record", "name": "ReportEvent"}, "type": "array"}, "name":
"reportEvents"}, {"doc": "", "type": ["null", {"values": "string",
"type": "map"}], "name": "additionalTextualVariantAnnotations"},
{"doc": "", "type": ["null", {"values": "float", "type": "map"}],
"name": "additionalNumericVariantAnnotations"}, {"doc": "", "type":
["null", {"items": "string", "type": "array"}], "name": "comments"}],
"type": "record", "name": "ReportedStructuralVariant"}, "name":
"reportedStructuralVariant"}, {"doc": "", "type": {"symbols":
["unknown", "somatic", "germline"], "doc": "", "type": "enum", "name":
"SomaticOrGermline"}, "name": "somaticOrGermline"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "reportedStructuralVariant",
        "somaticOrGermline",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'reportedStructuralVariant': ReportedStructuralVariant,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'reportedStructuralVariant': ReportedStructuralVariant,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'reportedStructuralVariant', 'somaticOrGermline'
    ]

    def __init__(self, **kwargs):
        self.reportedStructuralVariant = kwargs.get(
            'reportedStructuralVariant', None)
        self.somaticOrGermline = kwargs.get(
            'somaticOrGermline', None)


class ReportedSomaticVariants(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"ReportedSomaticVariants", "fields": [{"doc": "", "type": {"fields":
[{"doc": "", "type": "string", "name": "chromosome"}, {"doc": "",
"type": ["null", "string"], "name": "dbSNPid"}, {"doc": "", "type":
"int", "name": "position"}, {"doc": "", "type": "string", "name":
"reference"}, {"doc": "", "type": "string", "name": "alternate"},
{"doc": "", "type": {"items": {"doc": "", "type": "record", "name":
"CalledGenotype", "fields": [{"doc": "", "type": "string", "name":
"gelId"}, {"doc": "", "type": "string", "name": "genotype"}, {"doc":
"", "type": ["null", "int"], "name": "depthReference"}, {"doc": "",
"type": ["null", "int"], "name": "depthAlternate"}, {"doc": "",
"type": ["null", "int"], "name": "copyNumber"}]}, "type": "array"},
"name": "calledGenotypes"}, {"doc": "", "type": {"items": {"fields":
[{"doc": "", "type": "string", "name": "reportEventId"}, {"doc": "",
"type": "string", "name": "modeOfInheritance"}, {"doc": "", "type":
{"fields": [{"doc": "", "type": "string", "name": "geneSymbol"},
{"doc": "", "type": "string", "name": "transcriptId"}, {"doc": "",
"type": {"values": "string", "type": "map"}, "name": "ids"}, {"doc":
"", "type": ["null", "double"], "name": "geneCoverage"}], "type":
"record", "name": "Transcript"}, "name": "transcript"}, {"doc": "",
"type": {"symbols": ["complete", "incomplete"], "doc": "", "type":
"enum", "name": "Penetrance"}, "name": "penetrance"}, {"doc": "",
"type": "float", "name": "score"}, {"doc": "", "type": ["null",
{"values": "float", "type": "map"}], "name": "vendorSpecificScores"},
{"doc": "", "type": ["null", {"symbols": ["BENIGN", "LIKELY_BENIGN",
"VUS", "LIKELY_PATHOGENIC", "PATHOGENIC"], "doc": "", "type": "enum",
"name": "VariantClassification"}], "name": "variantClassification"},
{"doc": "", "type": ["null", "boolean"], "name":
"fullyExplainsPhenotype"}, {"doc": "", "type": ["null", "int"],
"name": "groupOfVariants"}, {"doc": "", "type": "string", "name":
"eventJustification"}, {"doc": "", "type": ["null", {"symbols":
["NONE", "TIER1", "TIER2", "TIER3"], "doc": "", "type": "enum",
"name": "Tier"}], "name": "tier"}], "type": "record", "name":
"ReportEvent"}, "type": "array"}, "name": "reportEvents"}, {"doc": "",
"type": ["null", {"values": "string", "type": "map"}], "name":
"additionalTextualVariantAnnotations"}, {"doc": "", "type": ["null",
{"values": "float", "type": "map"}], "name":
"additionalNumericVariantAnnotations"}, {"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "comments"}], "type":
"record", "name": "ReportedVariant"}, "name": "reportedVariant"},
{"doc": "", "type": {"symbols": ["unknown", "somatic", "germline"],
"doc": "", "type": "enum", "name": "SomaticOrGermline"}, "name":
"somaticOrGermline"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "reportedVariant",
        "somaticOrGermline",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'reportedVariant': ReportedVariant,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'reportedVariant': ReportedVariant,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'reportedVariant', 'somaticOrGermline'
    ]

    def __init__(self, **kwargs):
        self.reportedVariant = kwargs.get(
            'reportedVariant', None)
        self.somaticOrGermline = kwargs.get(
            'somaticOrGermline', None)


class ReportedStructuralVariant(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"ReportedStructuralVariant", "fields": [{"doc": "", "type": "string",
"name": "chromosome"}, {"doc": "", "type": "int", "name": "start"},
{"doc": "", "type": "int", "name": "end"}, {"doc": "", "type":
"string", "name": "type"}, {"doc": "", "type": "string", "name":
"reference"}, {"doc": "", "type": "string", "name": "alternate"},
{"type": {"items": {"doc": "", "type": "record", "name":
"CalledGenotype", "fields": [{"doc": "", "type": "string", "name":
"gelId"}, {"doc": "", "type": "string", "name": "genotype"}, {"doc":
"", "type": ["null", "int"], "name": "depthReference"}, {"doc": "",
"type": ["null", "int"], "name": "depthAlternate"}, {"doc": "",
"type": ["null", "int"], "name": "copyNumber"}]}, "type": "array"},
"name": "calledGenotypes"}, {"doc": "", "type": {"items": {"fields":
[{"doc": "", "type": "string", "name": "reportEventId"}, {"doc": "",
"type": "string", "name": "modeOfInheritance"}, {"doc": "", "type":
{"fields": [{"doc": "", "type": "string", "name": "geneSymbol"},
{"doc": "", "type": "string", "name": "transcriptId"}, {"doc": "",
"type": {"values": "string", "type": "map"}, "name": "ids"}, {"doc":
"", "type": ["null", "double"], "name": "geneCoverage"}], "type":
"record", "name": "Transcript"}, "name": "transcript"}, {"doc": "",
"type": {"symbols": ["complete", "incomplete"], "doc": "", "type":
"enum", "name": "Penetrance"}, "name": "penetrance"}, {"doc": "",
"type": "float", "name": "score"}, {"doc": "", "type": ["null",
{"values": "float", "type": "map"}], "name": "vendorSpecificScores"},
{"doc": "", "type": ["null", {"symbols": ["BENIGN", "LIKELY_BENIGN",
"VUS", "LIKELY_PATHOGENIC", "PATHOGENIC"], "doc": "", "type": "enum",
"name": "VariantClassification"}], "name": "variantClassification"},
{"doc": "", "type": ["null", "boolean"], "name":
"fullyExplainsPhenotype"}, {"doc": "", "type": ["null", "int"],
"name": "groupOfVariants"}, {"doc": "", "type": "string", "name":
"eventJustification"}, {"doc": "", "type": ["null", {"symbols":
["NONE", "TIER1", "TIER2", "TIER3"], "doc": "", "type": "enum",
"name": "Tier"}], "name": "tier"}], "type": "record", "name":
"ReportEvent"}, "type": "array"}, "name": "reportEvents"}, {"doc": "",
"type": ["null", {"values": "string", "type": "map"}], "name":
"additionalTextualVariantAnnotations"}, {"doc": "", "type": ["null",
{"values": "float", "type": "map"}], "name":
"additionalNumericVariantAnnotations"}, {"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "comments"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "additionalNumericVariantAnnotations",
        "additionalTextualVariantAnnotations",
        "alternate",
        "calledGenotypes",
        "chromosome",
        "comments",
        "end",
        "reference",
        "reportEvents",
        "start",
        "type",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calledGenotypes': CalledGenotype,
            'reportEvents': ReportEvent,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calledGenotypes': CalledGenotype,
            'reportEvents': ReportEvent,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'additionalNumericVariantAnnotations',
        'additionalTextualVariantAnnotations', 'alternate',
        'calledGenotypes', 'chromosome', 'comments', 'end',
        'reference', 'reportEvents', 'start', 'type'
    ]

    def __init__(self, **kwargs):
        self.additionalNumericVariantAnnotations = kwargs.get(
            'additionalNumericVariantAnnotations', None)
        self.additionalTextualVariantAnnotations = kwargs.get(
            'additionalTextualVariantAnnotations', None)
        self.alternate = kwargs.get(
            'alternate', 'None')
        self.calledGenotypes = kwargs.get(
            'calledGenotypes', None)
        self.chromosome = kwargs.get(
            'chromosome', 'None')
        self.comments = kwargs.get(
            'comments', None)
        self.end = kwargs.get(
            'end', None)
        self.reference = kwargs.get(
            'reference', 'None')
        self.reportEvents = kwargs.get(
            'reportEvents', None)
        self.start = kwargs.get(
            'start', None)
        self.type = kwargs.get(
            'type', 'None')


class ReportedVariant(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"ReportedVariant", "fields": [{"doc": "", "type": "string", "name":
"chromosome"}, {"doc": "", "type": ["null", "string"], "name":
"dbSNPid"}, {"doc": "", "type": "int", "name": "position"}, {"doc":
"", "type": "string", "name": "reference"}, {"doc": "", "type":
"string", "name": "alternate"}, {"doc": "", "type": {"items": {"doc":
"", "type": "record", "name": "CalledGenotype", "fields": [{"doc": "",
"type": "string", "name": "gelId"}, {"doc": "", "type": "string",
"name": "genotype"}, {"doc": "", "type": ["null", "int"], "name":
"depthReference"}, {"doc": "", "type": ["null", "int"], "name":
"depthAlternate"}, {"doc": "", "type": ["null", "int"], "name":
"copyNumber"}]}, "type": "array"}, "name": "calledGenotypes"}, {"doc":
"", "type": {"items": {"fields": [{"doc": "", "type": "string",
"name": "reportEventId"}, {"doc": "", "type": "string", "name":
"modeOfInheritance"}, {"doc": "", "type": {"fields": [{"doc": "",
"type": "string", "name": "geneSymbol"}, {"doc": "", "type": "string",
"name": "transcriptId"}, {"doc": "", "type": {"values": "string",
"type": "map"}, "name": "ids"}, {"doc": "", "type": ["null",
"double"], "name": "geneCoverage"}], "type": "record", "name":
"Transcript"}, "name": "transcript"}, {"doc": "", "type": {"symbols":
["complete", "incomplete"], "doc": "", "type": "enum", "name":
"Penetrance"}, "name": "penetrance"}, {"doc": "", "type": "float",
"name": "score"}, {"doc": "", "type": ["null", {"values": "float",
"type": "map"}], "name": "vendorSpecificScores"}, {"doc": "", "type":
["null", {"symbols": ["BENIGN", "LIKELY_BENIGN", "VUS",
"LIKELY_PATHOGENIC", "PATHOGENIC"], "doc": "", "type": "enum", "name":
"VariantClassification"}], "name": "variantClassification"}, {"doc":
"", "type": ["null", "boolean"], "name": "fullyExplainsPhenotype"},
{"doc": "", "type": ["null", "int"], "name": "groupOfVariants"},
{"doc": "", "type": "string", "name": "eventJustification"}, {"doc":
"", "type": ["null", {"symbols": ["NONE", "TIER1", "TIER2", "TIER3"],
"doc": "", "type": "enum", "name": "Tier"}], "name": "tier"}], "type":
"record", "name": "ReportEvent"}, "type": "array"}, "name":
"reportEvents"}, {"doc": "", "type": ["null", {"values": "string",
"type": "map"}], "name": "additionalTextualVariantAnnotations"},
{"doc": "", "type": ["null", {"values": "float", "type": "map"}],
"name": "additionalNumericVariantAnnotations"}, {"doc": "", "type":
["null", {"items": "string", "type": "array"}], "name": "comments"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "additionalNumericVariantAnnotations",
        "additionalTextualVariantAnnotations",
        "alternate",
        "calledGenotypes",
        "chromosome",
        "comments",
        "dbSNPid",
        "position",
        "reference",
        "reportEvents",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calledGenotypes': CalledGenotype,
            'reportEvents': ReportEvent,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'calledGenotypes': CalledGenotype,
            'reportEvents': ReportEvent,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'additionalNumericVariantAnnotations',
        'additionalTextualVariantAnnotations', 'alternate',
        'calledGenotypes', 'chromosome', 'comments', 'dbSNPid',
        'position', 'reference', 'reportEvents'
    ]

    def __init__(self, **kwargs):
        self.additionalNumericVariantAnnotations = kwargs.get(
            'additionalNumericVariantAnnotations', None)
        self.additionalTextualVariantAnnotations = kwargs.get(
            'additionalTextualVariantAnnotations', None)
        self.alternate = kwargs.get(
            'alternate', 'None')
        self.calledGenotypes = kwargs.get(
            'calledGenotypes', None)
        self.chromosome = kwargs.get(
            'chromosome', 'None')
        self.comments = kwargs.get(
            'comments', None)
        self.dbSNPid = kwargs.get(
            'dbSNPid', None)
        self.position = kwargs.get(
            'position', None)
        self.reference = kwargs.get(
            'reference', 'None')
        self.reportEvents = kwargs.get(
            'reportEvents', None)


class SampleType(object):
    """
    No documentation
    """
    germline = "germline"
    tumor = "tumor"


class SensitiveInformation(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"SensitiveInformation", "fields": [{"type": "string", "name":
"gelID"}, {"type": ["null", {"items": "string", "type": "array"}],
"name": "externalIds"}, {"type": ["null", "string"], "name":
"genomicMedicineCenter"}, {"type": ["null", "string"], "name":
"fullNameOfResponsibleConsultant"}, {"type": ["null", "string"],
"name": "contactNumber"}, {"type": ["null", "string"], "name":
"hospitalOfResponsibleConsultant"}, {"type": ["null", "string"],
"name": "centerSampleId"}, {"type": ["null", "string"], "name":
"originatingCenter"}, {"type": ["null", "string"], "name":
"centerPatientId"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "centerPatientId",
        "centerSampleId",
        "contactNumber",
        "externalIds",
        "fullNameOfResponsibleConsultant",
        "gelID",
        "genomicMedicineCenter",
        "hospitalOfResponsibleConsultant",
        "originatingCenter",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'centerPatientId', 'centerSampleId', 'contactNumber',
        'externalIds', 'fullNameOfResponsibleConsultant', 'gelID',
        'genomicMedicineCenter', 'hospitalOfResponsibleConsultant',
        'originatingCenter'
    ]

    def __init__(self, **kwargs):
        self.centerPatientId = kwargs.get(
            'centerPatientId', None)
        self.centerSampleId = kwargs.get(
            'centerSampleId', None)
        self.contactNumber = kwargs.get(
            'contactNumber', None)
        self.externalIds = kwargs.get(
            'externalIds', None)
        self.fullNameOfResponsibleConsultant = kwargs.get(
            'fullNameOfResponsibleConsultant', None)
        self.gelID = kwargs.get(
            'gelID', 'None')
        self.genomicMedicineCenter = kwargs.get(
            'genomicMedicineCenter', None)
        self.hospitalOfResponsibleConsultant = kwargs.get(
            'hospitalOfResponsibleConsultant', None)
        self.originatingCenter = kwargs.get(
            'originatingCenter', None)


class Sequencing(ProtocolElement):
    """
    The accreditation status of the laboratory/test should be
    indicated according to UKAS guidelines, if applicable (ACGS).
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"Sequencing", "fields": [{"doc": "", "type": "string", "name":
"SequencingCentre"}, {"doc": "", "type": "string", "name":
"SequencingAddress"}, {"doc": "", "type": ["null", "string"], "name":
"AccreditationStatus"}, {"doc": "", "type": ["null", "string"],
"name": "AccreditationDate"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "AccreditationDate",
        "AccreditationStatus",
        "SequencingAddress",
        "SequencingCentre",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'AccreditationDate', 'AccreditationStatus',
        'SequencingAddress', 'SequencingCentre'
    ]

    def __init__(self, **kwargs):
        self.AccreditationDate = kwargs.get(
            'AccreditationDate', None)
        self.AccreditationStatus = kwargs.get(
            'AccreditationStatus', None)
        self.SequencingAddress = kwargs.get(
            'SequencingAddress', 'None')
        self.SequencingCentre = kwargs.get(
            'SequencingCentre', 'None')


class Sex(object):
    """
    Sex
    """
    male = "male"
    female = "female"
    undetermined = "undetermined"


class SomaticOrGermline(object):
    """
    this defines whether the variant reported is considered to be a
    somatic or germline finding.
    """
    unknown = "unknown"
    somatic = "somatic"
    germline = "germline"


class TernaryOption(object):
    """
    This the define a yes/no/unknown case
    """
    yes = "yes"
    no = "no"
    unknown = "unknown"


class Tier(object):
    """
    Possible tiers as defined by Genomics England
    """
    NONE = "NONE"
    TIER1 = "TIER1"
    TIER2 = "TIER2"
    TIER3 = "TIER3"


class TieredVariants(ProtocolElement):
    """
    Unique to case log
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"TieredVariants", "fields": [{"doc": "", "type": ["null", "double"],
"name": "totalNoTier1"}, {"doc": "", "type": ["null", "double"],
"name": "totalNoTier2"}, {"doc": "", "type": ["null", "double"],
"name": "totalNoTier3"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "totalNoTier1",
        "totalNoTier2",
        "totalNoTier3",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'totalNoTier1', 'totalNoTier2', 'totalNoTier3'
    ]

    def __init__(self, **kwargs):
        self.totalNoTier1 = kwargs.get(
            'totalNoTier1', None)
        self.totalNoTier2 = kwargs.get(
            'totalNoTier2', None)
        self.totalNoTier3 = kwargs.get(
            'totalNoTier3', None)


class Tracking(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"Tracking", "fields": [{"doc": "", "type": "string", "name":
"reportID"}, {"doc": "", "type": "float", "name": "reportDate"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "reportDate",
        "reportID",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'reportDate', 'reportID'
    ]

    def __init__(self, **kwargs):
        self.reportDate = kwargs.get(
            'reportDate', None)
        self.reportID = kwargs.get(
            'reportID', 'None')


class Transcript(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"Transcript", "fields": [{"doc": "", "type": "string", "name":
"geneSymbol"}, {"doc": "", "type": "string", "name": "transcriptId"},
{"doc": "", "type": {"values": "string", "type": "map"}, "name":
"ids"}, {"doc": "", "type": ["null", "double"], "name":
"geneCoverage"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "geneCoverage",
        "geneSymbol",
        "ids",
        "transcriptId",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'geneCoverage', 'geneSymbol', 'ids', 'transcriptId'
    ]

    def __init__(self, **kwargs):
        self.geneCoverage = kwargs.get(
            'geneCoverage', None)
        self.geneSymbol = kwargs.get(
            'geneSymbol', 'None')
        self.ids = kwargs.get(
            'ids', None)
        self.transcriptId = kwargs.get(
            'transcriptId', 'None')


class Tumour(ProtocolElement):
    """
    No documentation
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name": "Tumour",
"fields": [{"doc": "", "type": {"items": {"doc": "", "type": "record",
"name": "File", "fields": [{"doc": "", "type": ["null", "string",
{"items": "string", "type": "array"}], "name": "SampleId"}, {"doc":
"", "type": "string", "name": "URIFile"}]}, "type": "array"}, "name":
"tumourPurity"}, {"doc": "", "type": {"items": "File", "type":
"array"}, "name": "tumourPloidy"}]}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "tumourPloidy",
        "tumourPurity",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'tumourPloidy': File,
            'tumourPurity': File,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'tumourPloidy': File,
            'tumourPurity': File,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'tumourPloidy', 'tumourPurity'
    ]

    def __init__(self, **kwargs):
        self.tumourPloidy = kwargs.get(
            'tumourPloidy', None)
        self.tumourPurity = kwargs.get(
            'tumourPurity', None)


class VariantClassification(object):
    """
    This is the classification of the variant according to standard
    practice guidelines (e.g. ACMG)
    """
    BENIGN = "BENIGN"
    LIKELY_BENIGN = "LIKELY_BENIGN"
    VUS = "VUS"
    LIKELY_PATHOGENIC = "LIKELY_PATHOGENIC"
    PATHOGENIC = "PATHOGENIC"


class VariantFilters(ProtocolElement):
    """
    Unique to case log
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"VariantFilters", "fields": [{"doc": "", "type": ["null", "double"],
"name": "totalVariants"}, {"doc": "", "type": ["null", "double"],
"name": "totalRareVariants"}, {"doc": "", "type": ["null", "double"],
"name": "rareFunctionalVariants"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "rareFunctionalVariants",
        "totalRareVariants",
        "totalVariants",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'rareFunctionalVariants', 'totalRareVariants', 'totalVariants'
    ]

    def __init__(self, **kwargs):
        self.rareFunctionalVariants = kwargs.get(
            'rareFunctionalVariants', None)
        self.totalRareVariants = kwargs.get(
            'totalRareVariants', None)
        self.totalVariants = kwargs.get(
            'totalVariants', None)


class VariantMOI(ProtocolElement):
    """
    Unique to case log
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"VariantMOI", "fields": [{"doc": "", "type": ["null", "double"],
"name": "totalHeterozygousDominant"}, {"doc": "", "type": ["null",
"double"], "name": "totalHomozygousRecessive"}, {"doc": "", "type":
["null", "double"], "name": "totalCompoundHeterozygusRecessive"},
{"doc": "", "type": ["null", "double"], "name":
"totalXLinkedRecessive"}, {"doc": "", "type": ["null", "double"],
"name": "totalXLinkedDominant"}, {"doc": "", "type": ["null",
"double"], "name": "deNovo"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "deNovo",
        "totalCompoundHeterozygusRecessive",
        "totalHeterozygousDominant",
        "totalHomozygousRecessive",
        "totalXLinkedDominant",
        "totalXLinkedRecessive",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {}
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {}

        return embeddedTypes[fieldName]

    __slots__ = [
        'deNovo', 'totalCompoundHeterozygusRecessive',
        'totalHeterozygousDominant', 'totalHomozygousRecessive',
        'totalXLinkedDominant', 'totalXLinkedRecessive'
    ]

    def __init__(self, **kwargs):
        self.deNovo = kwargs.get(
            'deNovo', None)
        self.totalCompoundHeterozygusRecessive = kwargs.get(
            'totalCompoundHeterozygusRecessive', None)
        self.totalHeterozygousDominant = kwargs.get(
            'totalHeterozygousDominant', None)
        self.totalHomozygousRecessive = kwargs.get(
            'totalHomozygousRecessive', None)
        self.totalXLinkedDominant = kwargs.get(
            'totalXLinkedDominant', None)
        self.totalXLinkedRecessive = kwargs.get(
            'totalXLinkedRecessive', None)


class VirtualPanel(ProtocolElement):
    """
    This record defines a gene panel.
    """
    _schemaSource = """
{"namespace": "Gel_BioInf_Models", "type": "record", "name":
"VirtualPanel", "fields": [{"doc": "", "type": "string", "name":
"specificDiseaseTitle"}, {"doc": "", "type": "string", "name":
"panelVersion"}, {"doc": "", "type": "string", "name":
"ensemblVersion"}, {"doc": "", "type": "string", "name":
"dataModelCatalogueVersion"}, {"doc": "", "type": {"items": "string",
"type": "array"}, "name": "geneIds"}, {"doc": "", "type": ["null",
{"items": "string", "type": "array"}], "name": "Transcripts"}, {"doc":
"", "type": ["null", {"doc": "", "type": "record", "name": "File",
"fields": [{"doc": "", "type": ["null", "string", {"items": "string",
"type": "array"}], "name": "SampleId"}, {"doc": "", "type": "string",
"name": "URIFile"}]}], "name": "relevantRegions"}, {"doc": "", "type":
["null", "File"], "name": "clinicalRelevantVariants"}], "doc": ""}
"""
    schema = avro.schema.parse(_schemaSource)
    requiredFields = {
        "Transcripts",
        "clinicalRelevantVariants",
        "dataModelCatalogueVersion",
        "ensemblVersion",
        "geneIds",
        "panelVersion",
        "relevantRegions",
        "specificDiseaseTitle",
    }

    @classmethod
    def isEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'clinicalRelevantVariants': File,
            'relevantRegions': File,
        }
        return fieldName in embeddedTypes

    @classmethod
    def getEmbeddedType(cls, fieldName):
        embeddedTypes = {
            'clinicalRelevantVariants': File,
            'relevantRegions': File,
        }

        return embeddedTypes[fieldName]

    __slots__ = [
        'Transcripts', 'clinicalRelevantVariants',
        'dataModelCatalogueVersion', 'ensemblVersion', 'geneIds',
        'panelVersion', 'relevantRegions', 'specificDiseaseTitle'
    ]

    def __init__(self, **kwargs):
        self.Transcripts = kwargs.get(
            'Transcripts', None)
        self.clinicalRelevantVariants = kwargs.get(
            'clinicalRelevantVariants', None)
        self.dataModelCatalogueVersion = kwargs.get(
            'dataModelCatalogueVersion', 'None')
        self.ensemblVersion = kwargs.get(
            'ensemblVersion', 'None')
        self.geneIds = kwargs.get(
            'geneIds', None)
        self.panelVersion = kwargs.get(
            'panelVersion', 'None')
        self.relevantRegions = kwargs.get(
            'relevantRegions', None)
        self.specificDiseaseTitle = kwargs.get(
            'specificDiseaseTitle', 'None')
